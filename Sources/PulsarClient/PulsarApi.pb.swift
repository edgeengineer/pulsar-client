// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: PulsarApi.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// Licensed to the Apache Software Foundation (ASF) under one
/// or more contributor license agreements.  See the NOTICE file
/// distributed with this work for additional information
/// regarding copyright ownership.  The ASF licenses this file
/// to you under the Apache License, Version 2.0 (the
/// "License"); you may not use this file except in compliance
/// with the License.  You may obtain a copy of the License at
///
///   http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing,
/// software distributed under the License is distributed on an
/// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
/// KIND, either express or implied.  See the License for the
/// specific language governing permissions and limitations
/// under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Pulsar_Proto_CompressionType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case none = 0
  case lz4 = 1
  case zlib = 2
  case zstd = 3
  case snappy = 4

  public init() {
    self = .none
  }

}

public enum Pulsar_Proto_ProducerAccessMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

  /// By default multiple producers can publish on a topic
  case shared = 0

  /// Require exclusive access for producer. Fail immediately if there's already a producer connected.
  case exclusive = 1

  /// Producer creation is pending until it can acquire exclusive access
  case waitForExclusive = 2

  /// Require exclusive access for producer. Fence out old producer.
  case exclusiveWithFencing = 3

  public init() {
    self = .shared
  }

}

public enum Pulsar_Proto_ServerError: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case unknownError = 0

  /// Error with ZK/metadata
  case metadataError = 1

  /// Error writing reading from BK
  case persistenceError = 2

  /// Non valid authentication
  case authenticationError = 3

  /// Not authorized to use resource
  case authorizationError = 4

  /// Unable to subscribe/unsubscribe because
  case consumerBusy = 5

  /// other consumers are connected
  case serviceNotReady = 6

  /// Unable to create producer because backlog quota exceeded
  case producerBlockedQuotaExceededError = 7

  /// Exception while creating producer because quota exceeded
  case producerBlockedQuotaExceededException = 8

  /// Error while verifying message checksum
  case checksumError = 9

  /// Error when an older client/version doesn't support a required feature
  case unsupportedVersionError = 10

  /// Topic not found
  case topicNotFound = 11

  /// Subscription not found
  case subscriptionNotFound = 12

  /// Consumer not found
  case consumerNotFound = 13

  /// Error with too many simultaneously request
  case tooManyRequests = 14

  /// The topic has been terminated
  case topicTerminatedError = 15

  /// Producer with same name is already connected
  case producerBusy = 16

  /// The topic name is not valid
  case invalidTopicName = 17

  /// Specified schema was incompatible with topic schema
  case incompatibleSchema = 18

  /// Dispatcher assign consumer error
  case consumerAssignError = 19

  /// Transaction coordinator not found error
  case transactionCoordinatorNotFound = 20

  /// Invalid txn status error
  case invalidTxnStatus = 21

  /// Not allowed error
  case notAllowedError = 22

  /// Ack with transaction conflict
  case transactionConflict = 23

  /// Transaction not found
  case transactionNotFound = 24

  /// When a producer asks and fail to get exclusive producer access,
  case producerFenced = 25

  public init() {
    self = .unknownError
  }

}

public enum Pulsar_Proto_AuthMethod: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case none = 0
  case ycaV1 = 1
  case athens = 2

  public init() {
    self = .none
  }

}

/// Each protocol version identify new features that are
/// incrementally added to the protocol
public enum Pulsar_Proto_ProtocolVersion: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

  /// Initial versioning
  case v0 = 0

  /// Added application keep-alive
  case v1 = 1

  /// Added RedeliverUnacknowledgedMessages Command
  case v2 = 2

  /// Added compression with LZ4 and ZLib
  case v3 = 3

  /// Added batch message support
  case v4 = 4

  /// Added disconnect client w/o closing connection
  case v5 = 5

  /// Added checksum computation for metadata + payload
  case v6 = 6

  /// Added CommandLookupTopic - Binary Lookup
  case v7 = 7

  /// Added CommandConsumerStats - Client fetches broker side consumer stats
  case v8 = 8

  /// Added end of topic notification
  case v9 = 9

  /// Added proxy to broker
  case v10 = 10

  /// C++ consumers before this version are not correctly handling the checksum field
  case v11 = 11

  /// Added get topic's last messageId from broker
  case v12 = 12

  /// Added CommandActiveConsumerChange
  /// Added CommandGetTopicsOfNamespace
  case v13 = 13

  /// Add CommandAuthChallenge and CommandAuthResponse for mutual auth
  case v14 = 14

  /// Added Key_Shared subscription
  case v15 = 15

  /// Add support for broker entry metadata
  case v16 = 16

  /// Added support ack receipt
  case v17 = 17

  /// Add client support for broker entry metadata
  case v18 = 18

  /// Add CommandTcClientConnectRequest and CommandTcClientConnectResponse
  case v19 = 19

  /// Add client support for topic migration redirection CommandTopicMigrated
  case v20 = 20

  /// Carry the AUTO_CONSUME schema to the Broker after this version
  case v21 = 21

  public init() {
    self = .v0
  }

}

public enum Pulsar_Proto_KeySharedMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case autoSplit = 0
  case sticky = 1

  public init() {
    self = .autoSplit
  }

}

public enum Pulsar_Proto_TxnAction: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case commit = 0
  case abort = 1

  public init() {
    self = .commit
  }

}

public struct Pulsar_Proto_Schema: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var schemaData: Data {
    get {return _schemaData ?? Data()}
    set {_schemaData = newValue}
  }
  /// Returns true if `schemaData` has been explicitly set.
  public var hasSchemaData: Bool {return self._schemaData != nil}
  /// Clears the value of `schemaData`. Subsequent reads from it will return its default value.
  public mutating func clearSchemaData() {self._schemaData = nil}

  public var type: Pulsar_Proto_Schema.TypeEnum {
    get {return _type ?? .none}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var properties: [Pulsar_Proto_KeyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case string = 1
    case json = 2
    case protobuf = 3
    case avro = 4
    case bool = 5
    case int8 = 6
    case int16 = 7
    case int32 = 8
    case int64 = 9
    case float = 10
    case double = 11
    case date = 12
    case time = 13
    case timestamp = 14
    case keyValue = 15
    case instant = 16
    case localDate = 17
    case localTime = 18
    case localDateTime = 19
    case protobufNative = 20
    case autoConsume = 21

    public init() {
      self = .none
    }

  }

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _schemaData: Data? = nil
  fileprivate var _type: Pulsar_Proto_Schema.TypeEnum? = nil
}

public struct Pulsar_Proto_MessageIdData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ledgerID: UInt64 {
    get {return _storage._ledgerID ?? 0}
    set {_uniqueStorage()._ledgerID = newValue}
  }
  /// Returns true if `ledgerID` has been explicitly set.
  public var hasLedgerID: Bool {return _storage._ledgerID != nil}
  /// Clears the value of `ledgerID`. Subsequent reads from it will return its default value.
  public mutating func clearLedgerID() {_uniqueStorage()._ledgerID = nil}

  public var entryID: UInt64 {
    get {return _storage._entryID ?? 0}
    set {_uniqueStorage()._entryID = newValue}
  }
  /// Returns true if `entryID` has been explicitly set.
  public var hasEntryID: Bool {return _storage._entryID != nil}
  /// Clears the value of `entryID`. Subsequent reads from it will return its default value.
  public mutating func clearEntryID() {_uniqueStorage()._entryID = nil}

  public var partition: Int32 {
    get {return _storage._partition ?? -1}
    set {_uniqueStorage()._partition = newValue}
  }
  /// Returns true if `partition` has been explicitly set.
  public var hasPartition: Bool {return _storage._partition != nil}
  /// Clears the value of `partition`. Subsequent reads from it will return its default value.
  public mutating func clearPartition() {_uniqueStorage()._partition = nil}

  public var batchIndex: Int32 {
    get {return _storage._batchIndex ?? -1}
    set {_uniqueStorage()._batchIndex = newValue}
  }
  /// Returns true if `batchIndex` has been explicitly set.
  public var hasBatchIndex: Bool {return _storage._batchIndex != nil}
  /// Clears the value of `batchIndex`. Subsequent reads from it will return its default value.
  public mutating func clearBatchIndex() {_uniqueStorage()._batchIndex = nil}

  public var ackSet: [Int64] {
    get {return _storage._ackSet}
    set {_uniqueStorage()._ackSet = newValue}
  }

  public var batchSize: Int32 {
    get {return _storage._batchSize ?? 0}
    set {_uniqueStorage()._batchSize = newValue}
  }
  /// Returns true if `batchSize` has been explicitly set.
  public var hasBatchSize: Bool {return _storage._batchSize != nil}
  /// Clears the value of `batchSize`. Subsequent reads from it will return its default value.
  public mutating func clearBatchSize() {_uniqueStorage()._batchSize = nil}

  /// For the chunk message id, we need to specify the first chunk message id.
  public var firstChunkMessageID: Pulsar_Proto_MessageIdData {
    get {return _storage._firstChunkMessageID ?? Pulsar_Proto_MessageIdData()}
    set {_uniqueStorage()._firstChunkMessageID = newValue}
  }
  /// Returns true if `firstChunkMessageID` has been explicitly set.
  public var hasFirstChunkMessageID: Bool {return _storage._firstChunkMessageID != nil}
  /// Clears the value of `firstChunkMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearFirstChunkMessageID() {_uniqueStorage()._firstChunkMessageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pulsar_Proto_KeyValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
}

public struct Pulsar_Proto_KeyLongValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: UInt64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: UInt64? = nil
}

public struct Pulsar_Proto_IntRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var start: Int32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  public var end: Int32 {
    get {return _end ?? 0}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: Int32? = nil
  fileprivate var _end: Int32? = nil
}

public struct Pulsar_Proto_EncryptionKeys: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: Data {
    get {return _value ?? Data()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var metadata: [Pulsar_Proto_KeyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: Data? = nil
}

public struct Pulsar_Proto_MessageMetadata: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var producerName: String {
    get {return _storage._producerName ?? String()}
    set {_uniqueStorage()._producerName = newValue}
  }
  /// Returns true if `producerName` has been explicitly set.
  public var hasProducerName: Bool {return _storage._producerName != nil}
  /// Clears the value of `producerName`. Subsequent reads from it will return its default value.
  public mutating func clearProducerName() {_uniqueStorage()._producerName = nil}

  public var sequenceID: UInt64 {
    get {return _storage._sequenceID ?? 0}
    set {_uniqueStorage()._sequenceID = newValue}
  }
  /// Returns true if `sequenceID` has been explicitly set.
  public var hasSequenceID: Bool {return _storage._sequenceID != nil}
  /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearSequenceID() {_uniqueStorage()._sequenceID = nil}

  public var publishTime: UInt64 {
    get {return _storage._publishTime ?? 0}
    set {_uniqueStorage()._publishTime = newValue}
  }
  /// Returns true if `publishTime` has been explicitly set.
  public var hasPublishTime: Bool {return _storage._publishTime != nil}
  /// Clears the value of `publishTime`. Subsequent reads from it will return its default value.
  public mutating func clearPublishTime() {_uniqueStorage()._publishTime = nil}

  public var properties: [Pulsar_Proto_KeyValue] {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  /// Property set on replicated message,
  /// includes the source cluster name
  public var replicatedFrom: String {
    get {return _storage._replicatedFrom ?? String()}
    set {_uniqueStorage()._replicatedFrom = newValue}
  }
  /// Returns true if `replicatedFrom` has been explicitly set.
  public var hasReplicatedFrom: Bool {return _storage._replicatedFrom != nil}
  /// Clears the value of `replicatedFrom`. Subsequent reads from it will return its default value.
  public mutating func clearReplicatedFrom() {_uniqueStorage()._replicatedFrom = nil}

  ///key to decide partition for the msg
  public var partitionKey: String {
    get {return _storage._partitionKey ?? String()}
    set {_uniqueStorage()._partitionKey = newValue}
  }
  /// Returns true if `partitionKey` has been explicitly set.
  public var hasPartitionKey: Bool {return _storage._partitionKey != nil}
  /// Clears the value of `partitionKey`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionKey() {_uniqueStorage()._partitionKey = nil}

  /// Override namespace's replication
  public var replicateTo: [String] {
    get {return _storage._replicateTo}
    set {_uniqueStorage()._replicateTo = newValue}
  }

  public var compression: Pulsar_Proto_CompressionType {
    get {return _storage._compression ?? .none}
    set {_uniqueStorage()._compression = newValue}
  }
  /// Returns true if `compression` has been explicitly set.
  public var hasCompression: Bool {return _storage._compression != nil}
  /// Clears the value of `compression`. Subsequent reads from it will return its default value.
  public mutating func clearCompression() {_uniqueStorage()._compression = nil}

  public var uncompressedSize: UInt32 {
    get {return _storage._uncompressedSize ?? 0}
    set {_uniqueStorage()._uncompressedSize = newValue}
  }
  /// Returns true if `uncompressedSize` has been explicitly set.
  public var hasUncompressedSize: Bool {return _storage._uncompressedSize != nil}
  /// Clears the value of `uncompressedSize`. Subsequent reads from it will return its default value.
  public mutating func clearUncompressedSize() {_uniqueStorage()._uncompressedSize = nil}

  /// Removed below checksum field from Metadata as
  /// it should be part of send-command which keeps checksum of header + payload
  ///optional sfixed64 checksum = 10;
  /// differentiate single and batch message metadata
  public var numMessagesInBatch: Int32 {
    get {return _storage._numMessagesInBatch ?? 1}
    set {_uniqueStorage()._numMessagesInBatch = newValue}
  }
  /// Returns true if `numMessagesInBatch` has been explicitly set.
  public var hasNumMessagesInBatch: Bool {return _storage._numMessagesInBatch != nil}
  /// Clears the value of `numMessagesInBatch`. Subsequent reads from it will return its default value.
  public mutating func clearNumMessagesInBatch() {_uniqueStorage()._numMessagesInBatch = nil}

  /// the timestamp that this event occurs. it is typically set by applications.
  /// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
  public var eventTime: UInt64 {
    get {return _storage._eventTime ?? 0}
    set {_uniqueStorage()._eventTime = newValue}
  }
  /// Returns true if `eventTime` has been explicitly set.
  public var hasEventTime: Bool {return _storage._eventTime != nil}
  /// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
  public mutating func clearEventTime() {_uniqueStorage()._eventTime = nil}

  /// Contains encryption key name, encrypted key and metadata to describe the key
  public var encryptionKeys: [Pulsar_Proto_EncryptionKeys] {
    get {return _storage._encryptionKeys}
    set {_uniqueStorage()._encryptionKeys = newValue}
  }

  /// Algorithm used to encrypt data key
  public var encryptionAlgo: String {
    get {return _storage._encryptionAlgo ?? String()}
    set {_uniqueStorage()._encryptionAlgo = newValue}
  }
  /// Returns true if `encryptionAlgo` has been explicitly set.
  public var hasEncryptionAlgo: Bool {return _storage._encryptionAlgo != nil}
  /// Clears the value of `encryptionAlgo`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptionAlgo() {_uniqueStorage()._encryptionAlgo = nil}

  /// Additional parameters required by encryption
  public var encryptionParam: Data {
    get {return _storage._encryptionParam ?? Data()}
    set {_uniqueStorage()._encryptionParam = newValue}
  }
  /// Returns true if `encryptionParam` has been explicitly set.
  public var hasEncryptionParam: Bool {return _storage._encryptionParam != nil}
  /// Clears the value of `encryptionParam`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptionParam() {_uniqueStorage()._encryptionParam = nil}

  public var schemaVersion: Data {
    get {return _storage._schemaVersion ?? Data()}
    set {_uniqueStorage()._schemaVersion = newValue}
  }
  /// Returns true if `schemaVersion` has been explicitly set.
  public var hasSchemaVersion: Bool {return _storage._schemaVersion != nil}
  /// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSchemaVersion() {_uniqueStorage()._schemaVersion = nil}

  public var partitionKeyB64Encoded: Bool {
    get {return _storage._partitionKeyB64Encoded ?? false}
    set {_uniqueStorage()._partitionKeyB64Encoded = newValue}
  }
  /// Returns true if `partitionKeyB64Encoded` has been explicitly set.
  public var hasPartitionKeyB64Encoded: Bool {return _storage._partitionKeyB64Encoded != nil}
  /// Clears the value of `partitionKeyB64Encoded`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionKeyB64Encoded() {_uniqueStorage()._partitionKeyB64Encoded = nil}

  /// Specific a key to overwrite the message key which used for ordering dispatch in Key_Shared mode.
  public var orderingKey: Data {
    get {return _storage._orderingKey ?? Data()}
    set {_uniqueStorage()._orderingKey = newValue}
  }
  /// Returns true if `orderingKey` has been explicitly set.
  public var hasOrderingKey: Bool {return _storage._orderingKey != nil}
  /// Clears the value of `orderingKey`. Subsequent reads from it will return its default value.
  public mutating func clearOrderingKey() {_uniqueStorage()._orderingKey = nil}

  /// Mark the message to be delivered at or after the specified timestamp
  public var deliverAtTime: Int64 {
    get {return _storage._deliverAtTime ?? 0}
    set {_uniqueStorage()._deliverAtTime = newValue}
  }
  /// Returns true if `deliverAtTime` has been explicitly set.
  public var hasDeliverAtTime: Bool {return _storage._deliverAtTime != nil}
  /// Clears the value of `deliverAtTime`. Subsequent reads from it will return its default value.
  public mutating func clearDeliverAtTime() {_uniqueStorage()._deliverAtTime = nil}

  /// Identify whether a message is a "marker" message used for
  /// internal metadata instead of application published data.
  /// Markers will generally not be propagated back to clients
  public var markerType: Int32 {
    get {return _storage._markerType ?? 0}
    set {_uniqueStorage()._markerType = newValue}
  }
  /// Returns true if `markerType` has been explicitly set.
  public var hasMarkerType: Bool {return _storage._markerType != nil}
  /// Clears the value of `markerType`. Subsequent reads from it will return its default value.
  public mutating func clearMarkerType() {_uniqueStorage()._markerType = nil}

  /// transaction related message info
  public var txnidLeastBits: UInt64 {
    get {return _storage._txnidLeastBits ?? 0}
    set {_uniqueStorage()._txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return _storage._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {_uniqueStorage()._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _storage._txnidMostBits ?? 0}
    set {_uniqueStorage()._txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return _storage._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {_uniqueStorage()._txnidMostBits = nil}

  //// Add highest sequence id to support batch message with external sequence id
  public var highestSequenceID: UInt64 {
    get {return _storage._highestSequenceID ?? 0}
    set {_uniqueStorage()._highestSequenceID = newValue}
  }
  /// Returns true if `highestSequenceID` has been explicitly set.
  public var hasHighestSequenceID: Bool {return _storage._highestSequenceID != nil}
  /// Clears the value of `highestSequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearHighestSequenceID() {_uniqueStorage()._highestSequenceID = nil}

  /// Indicate if the message payload value is set
  public var nullValue: Bool {
    get {return _storage._nullValue ?? false}
    set {_uniqueStorage()._nullValue = newValue}
  }
  /// Returns true if `nullValue` has been explicitly set.
  public var hasNullValue: Bool {return _storage._nullValue != nil}
  /// Clears the value of `nullValue`. Subsequent reads from it will return its default value.
  public mutating func clearNullValue() {_uniqueStorage()._nullValue = nil}

  public var uuid: String {
    get {return _storage._uuid ?? String()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  public var numChunksFromMsg: Int32 {
    get {return _storage._numChunksFromMsg ?? 0}
    set {_uniqueStorage()._numChunksFromMsg = newValue}
  }
  /// Returns true if `numChunksFromMsg` has been explicitly set.
  public var hasNumChunksFromMsg: Bool {return _storage._numChunksFromMsg != nil}
  /// Clears the value of `numChunksFromMsg`. Subsequent reads from it will return its default value.
  public mutating func clearNumChunksFromMsg() {_uniqueStorage()._numChunksFromMsg = nil}

  public var totalChunkMsgSize: Int32 {
    get {return _storage._totalChunkMsgSize ?? 0}
    set {_uniqueStorage()._totalChunkMsgSize = newValue}
  }
  /// Returns true if `totalChunkMsgSize` has been explicitly set.
  public var hasTotalChunkMsgSize: Bool {return _storage._totalChunkMsgSize != nil}
  /// Clears the value of `totalChunkMsgSize`. Subsequent reads from it will return its default value.
  public mutating func clearTotalChunkMsgSize() {_uniqueStorage()._totalChunkMsgSize = nil}

  public var chunkID: Int32 {
    get {return _storage._chunkID ?? 0}
    set {_uniqueStorage()._chunkID = newValue}
  }
  /// Returns true if `chunkID` has been explicitly set.
  public var hasChunkID: Bool {return _storage._chunkID != nil}
  /// Clears the value of `chunkID`. Subsequent reads from it will return its default value.
  public mutating func clearChunkID() {_uniqueStorage()._chunkID = nil}

  /// Indicate if the message partition key is set
  public var nullPartitionKey: Bool {
    get {return _storage._nullPartitionKey ?? false}
    set {_uniqueStorage()._nullPartitionKey = newValue}
  }
  /// Returns true if `nullPartitionKey` has been explicitly set.
  public var hasNullPartitionKey: Bool {return _storage._nullPartitionKey != nil}
  /// Clears the value of `nullPartitionKey`. Subsequent reads from it will return its default value.
  public mutating func clearNullPartitionKey() {_uniqueStorage()._nullPartitionKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pulsar_Proto_SingleMessageMetadata: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var properties: [Pulsar_Proto_KeyValue] = []

  public var partitionKey: String {
    get {return _partitionKey ?? String()}
    set {_partitionKey = newValue}
  }
  /// Returns true if `partitionKey` has been explicitly set.
  public var hasPartitionKey: Bool {return self._partitionKey != nil}
  /// Clears the value of `partitionKey`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionKey() {self._partitionKey = nil}

  public var payloadSize: Int32 {
    get {return _payloadSize ?? 0}
    set {_payloadSize = newValue}
  }
  /// Returns true if `payloadSize` has been explicitly set.
  public var hasPayloadSize: Bool {return self._payloadSize != nil}
  /// Clears the value of `payloadSize`. Subsequent reads from it will return its default value.
  public mutating func clearPayloadSize() {self._payloadSize = nil}

  public var compactedOut: Bool {
    get {return _compactedOut ?? false}
    set {_compactedOut = newValue}
  }
  /// Returns true if `compactedOut` has been explicitly set.
  public var hasCompactedOut: Bool {return self._compactedOut != nil}
  /// Clears the value of `compactedOut`. Subsequent reads from it will return its default value.
  public mutating func clearCompactedOut() {self._compactedOut = nil}

  /// the timestamp that this event occurs. it is typically set by applications.
  /// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
  public var eventTime: UInt64 {
    get {return _eventTime ?? 0}
    set {_eventTime = newValue}
  }
  /// Returns true if `eventTime` has been explicitly set.
  public var hasEventTime: Bool {return self._eventTime != nil}
  /// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
  public mutating func clearEventTime() {self._eventTime = nil}

  public var partitionKeyB64Encoded: Bool {
    get {return _partitionKeyB64Encoded ?? false}
    set {_partitionKeyB64Encoded = newValue}
  }
  /// Returns true if `partitionKeyB64Encoded` has been explicitly set.
  public var hasPartitionKeyB64Encoded: Bool {return self._partitionKeyB64Encoded != nil}
  /// Clears the value of `partitionKeyB64Encoded`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionKeyB64Encoded() {self._partitionKeyB64Encoded = nil}

  /// Specific a key to overwrite the message key which used for ordering dispatch in Key_Shared mode.
  public var orderingKey: Data {
    get {return _orderingKey ?? Data()}
    set {_orderingKey = newValue}
  }
  /// Returns true if `orderingKey` has been explicitly set.
  public var hasOrderingKey: Bool {return self._orderingKey != nil}
  /// Clears the value of `orderingKey`. Subsequent reads from it will return its default value.
  public mutating func clearOrderingKey() {self._orderingKey = nil}

  /// Allows consumer retrieve the sequence id that the producer set.
  public var sequenceID: UInt64 {
    get {return _sequenceID ?? 0}
    set {_sequenceID = newValue}
  }
  /// Returns true if `sequenceID` has been explicitly set.
  public var hasSequenceID: Bool {return self._sequenceID != nil}
  /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearSequenceID() {self._sequenceID = nil}

  /// Indicate if the message payload value is set
  public var nullValue: Bool {
    get {return _nullValue ?? false}
    set {_nullValue = newValue}
  }
  /// Returns true if `nullValue` has been explicitly set.
  public var hasNullValue: Bool {return self._nullValue != nil}
  /// Clears the value of `nullValue`. Subsequent reads from it will return its default value.
  public mutating func clearNullValue() {self._nullValue = nil}

  /// Indicate if the message partition key is set
  public var nullPartitionKey: Bool {
    get {return _nullPartitionKey ?? false}
    set {_nullPartitionKey = newValue}
  }
  /// Returns true if `nullPartitionKey` has been explicitly set.
  public var hasNullPartitionKey: Bool {return self._nullPartitionKey != nil}
  /// Clears the value of `nullPartitionKey`. Subsequent reads from it will return its default value.
  public mutating func clearNullPartitionKey() {self._nullPartitionKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _partitionKey: String? = nil
  fileprivate var _payloadSize: Int32? = nil
  fileprivate var _compactedOut: Bool? = nil
  fileprivate var _eventTime: UInt64? = nil
  fileprivate var _partitionKeyB64Encoded: Bool? = nil
  fileprivate var _orderingKey: Data? = nil
  fileprivate var _sequenceID: UInt64? = nil
  fileprivate var _nullValue: Bool? = nil
  fileprivate var _nullPartitionKey: Bool? = nil
}

/// metadata added for entry from broker
public struct Pulsar_Proto_BrokerEntryMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var brokerTimestamp: UInt64 {
    get {return _brokerTimestamp ?? 0}
    set {_brokerTimestamp = newValue}
  }
  /// Returns true if `brokerTimestamp` has been explicitly set.
  public var hasBrokerTimestamp: Bool {return self._brokerTimestamp != nil}
  /// Clears the value of `brokerTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearBrokerTimestamp() {self._brokerTimestamp = nil}

  public var index: UInt64 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  public var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  public mutating func clearIndex() {self._index = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _brokerTimestamp: UInt64? = nil
  fileprivate var _index: UInt64? = nil
}

public struct Pulsar_Proto_CommandConnect: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the client. Proxy should forward client's client_version.
  public var clientVersion: String {
    get {return _clientVersion ?? String()}
    set {_clientVersion = newValue}
  }
  /// Returns true if `clientVersion` has been explicitly set.
  public var hasClientVersion: Bool {return self._clientVersion != nil}
  /// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
  public mutating func clearClientVersion() {self._clientVersion = nil}

  /// Deprecated. Use "auth_method_name" instead.
  public var authMethod: Pulsar_Proto_AuthMethod {
    get {return _authMethod ?? .none}
    set {_authMethod = newValue}
  }
  /// Returns true if `authMethod` has been explicitly set.
  public var hasAuthMethod: Bool {return self._authMethod != nil}
  /// Clears the value of `authMethod`. Subsequent reads from it will return its default value.
  public mutating func clearAuthMethod() {self._authMethod = nil}

  public var authMethodName: String {
    get {return _authMethodName ?? String()}
    set {_authMethodName = newValue}
  }
  /// Returns true if `authMethodName` has been explicitly set.
  public var hasAuthMethodName: Bool {return self._authMethodName != nil}
  /// Clears the value of `authMethodName`. Subsequent reads from it will return its default value.
  public mutating func clearAuthMethodName() {self._authMethodName = nil}

  public var authData: Data {
    get {return _authData ?? Data()}
    set {_authData = newValue}
  }
  /// Returns true if `authData` has been explicitly set.
  public var hasAuthData: Bool {return self._authData != nil}
  /// Clears the value of `authData`. Subsequent reads from it will return its default value.
  public mutating func clearAuthData() {self._authData = nil}

  public var protocolVersion: Int32 {
    get {return _protocolVersion ?? 0}
    set {_protocolVersion = newValue}
  }
  /// Returns true if `protocolVersion` has been explicitly set.
  public var hasProtocolVersion: Bool {return self._protocolVersion != nil}
  /// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
  public mutating func clearProtocolVersion() {self._protocolVersion = nil}

  /// Client can ask to be proxyied to a specific broker
  /// This is only honored by a Pulsar proxy
  public var proxyToBrokerURL: String {
    get {return _proxyToBrokerURL ?? String()}
    set {_proxyToBrokerURL = newValue}
  }
  /// Returns true if `proxyToBrokerURL` has been explicitly set.
  public var hasProxyToBrokerURL: Bool {return self._proxyToBrokerURL != nil}
  /// Clears the value of `proxyToBrokerURL`. Subsequent reads from it will return its default value.
  public mutating func clearProxyToBrokerURL() {self._proxyToBrokerURL = nil}

  /// Original principal that was verified by
  /// a Pulsar proxy. In this case the auth info above
  /// will be the auth of the proxy itself
  public var originalPrincipal: String {
    get {return _originalPrincipal ?? String()}
    set {_originalPrincipal = newValue}
  }
  /// Returns true if `originalPrincipal` has been explicitly set.
  public var hasOriginalPrincipal: Bool {return self._originalPrincipal != nil}
  /// Clears the value of `originalPrincipal`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalPrincipal() {self._originalPrincipal = nil}

  /// Original auth role and auth Method that was passed
  /// to the proxy. In this case the auth info above
  /// will be the auth of the proxy itself
  public var originalAuthData: String {
    get {return _originalAuthData ?? String()}
    set {_originalAuthData = newValue}
  }
  /// Returns true if `originalAuthData` has been explicitly set.
  public var hasOriginalAuthData: Bool {return self._originalAuthData != nil}
  /// Clears the value of `originalAuthData`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalAuthData() {self._originalAuthData = nil}

  public var originalAuthMethod: String {
    get {return _originalAuthMethod ?? String()}
    set {_originalAuthMethod = newValue}
  }
  /// Returns true if `originalAuthMethod` has been explicitly set.
  public var hasOriginalAuthMethod: Bool {return self._originalAuthMethod != nil}
  /// Clears the value of `originalAuthMethod`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalAuthMethod() {self._originalAuthMethod = nil}

  /// Feature flags
  public var featureFlags: Pulsar_Proto_FeatureFlags {
    get {return _featureFlags ?? Pulsar_Proto_FeatureFlags()}
    set {_featureFlags = newValue}
  }
  /// Returns true if `featureFlags` has been explicitly set.
  public var hasFeatureFlags: Bool {return self._featureFlags != nil}
  /// Clears the value of `featureFlags`. Subsequent reads from it will return its default value.
  public mutating func clearFeatureFlags() {self._featureFlags = nil}

  /// Version of the proxy. Should only be forwarded by a proxy.
  public var proxyVersion: String {
    get {return _proxyVersion ?? String()}
    set {_proxyVersion = newValue}
  }
  /// Returns true if `proxyVersion` has been explicitly set.
  public var hasProxyVersion: Bool {return self._proxyVersion != nil}
  /// Clears the value of `proxyVersion`. Subsequent reads from it will return its default value.
  public mutating func clearProxyVersion() {self._proxyVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientVersion: String? = nil
  fileprivate var _authMethod: Pulsar_Proto_AuthMethod? = nil
  fileprivate var _authMethodName: String? = nil
  fileprivate var _authData: Data? = nil
  fileprivate var _protocolVersion: Int32? = nil
  fileprivate var _proxyToBrokerURL: String? = nil
  fileprivate var _originalPrincipal: String? = nil
  fileprivate var _originalAuthData: String? = nil
  fileprivate var _originalAuthMethod: String? = nil
  fileprivate var _featureFlags: Pulsar_Proto_FeatureFlags? = nil
  fileprivate var _proxyVersion: String? = nil
}

/// Please also add a new enum for the class "PulsarClientException.FailedFeatureCheck" when adding a new feature flag.
public struct Pulsar_Proto_FeatureFlags: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var supportsAuthRefresh: Bool {
    get {return _supportsAuthRefresh ?? false}
    set {_supportsAuthRefresh = newValue}
  }
  /// Returns true if `supportsAuthRefresh` has been explicitly set.
  public var hasSupportsAuthRefresh: Bool {return self._supportsAuthRefresh != nil}
  /// Clears the value of `supportsAuthRefresh`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsAuthRefresh() {self._supportsAuthRefresh = nil}

  public var supportsBrokerEntryMetadata: Bool {
    get {return _supportsBrokerEntryMetadata ?? false}
    set {_supportsBrokerEntryMetadata = newValue}
  }
  /// Returns true if `supportsBrokerEntryMetadata` has been explicitly set.
  public var hasSupportsBrokerEntryMetadata: Bool {return self._supportsBrokerEntryMetadata != nil}
  /// Clears the value of `supportsBrokerEntryMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsBrokerEntryMetadata() {self._supportsBrokerEntryMetadata = nil}

  public var supportsPartialProducer: Bool {
    get {return _supportsPartialProducer ?? false}
    set {_supportsPartialProducer = newValue}
  }
  /// Returns true if `supportsPartialProducer` has been explicitly set.
  public var hasSupportsPartialProducer: Bool {return self._supportsPartialProducer != nil}
  /// Clears the value of `supportsPartialProducer`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsPartialProducer() {self._supportsPartialProducer = nil}

  public var supportsTopicWatchers: Bool {
    get {return _supportsTopicWatchers ?? false}
    set {_supportsTopicWatchers = newValue}
  }
  /// Returns true if `supportsTopicWatchers` has been explicitly set.
  public var hasSupportsTopicWatchers: Bool {return self._supportsTopicWatchers != nil}
  /// Clears the value of `supportsTopicWatchers`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsTopicWatchers() {self._supportsTopicWatchers = nil}

  public var supportsGetPartitionedMetadataWithoutAutoCreation: Bool {
    get {return _supportsGetPartitionedMetadataWithoutAutoCreation ?? false}
    set {_supportsGetPartitionedMetadataWithoutAutoCreation = newValue}
  }
  /// Returns true if `supportsGetPartitionedMetadataWithoutAutoCreation` has been explicitly set.
  public var hasSupportsGetPartitionedMetadataWithoutAutoCreation: Bool {return self._supportsGetPartitionedMetadataWithoutAutoCreation != nil}
  /// Clears the value of `supportsGetPartitionedMetadataWithoutAutoCreation`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsGetPartitionedMetadataWithoutAutoCreation() {self._supportsGetPartitionedMetadataWithoutAutoCreation = nil}

  public var supportsReplDedupByLidAndEid: Bool {
    get {return _supportsReplDedupByLidAndEid ?? false}
    set {_supportsReplDedupByLidAndEid = newValue}
  }
  /// Returns true if `supportsReplDedupByLidAndEid` has been explicitly set.
  public var hasSupportsReplDedupByLidAndEid: Bool {return self._supportsReplDedupByLidAndEid != nil}
  /// Clears the value of `supportsReplDedupByLidAndEid`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsReplDedupByLidAndEid() {self._supportsReplDedupByLidAndEid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _supportsAuthRefresh: Bool? = nil
  fileprivate var _supportsBrokerEntryMetadata: Bool? = nil
  fileprivate var _supportsPartialProducer: Bool? = nil
  fileprivate var _supportsTopicWatchers: Bool? = nil
  fileprivate var _supportsGetPartitionedMetadataWithoutAutoCreation: Bool? = nil
  fileprivate var _supportsReplDedupByLidAndEid: Bool? = nil
}

public struct Pulsar_Proto_CommandConnected: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverVersion: String {
    get {return _serverVersion ?? String()}
    set {_serverVersion = newValue}
  }
  /// Returns true if `serverVersion` has been explicitly set.
  public var hasServerVersion: Bool {return self._serverVersion != nil}
  /// Clears the value of `serverVersion`. Subsequent reads from it will return its default value.
  public mutating func clearServerVersion() {self._serverVersion = nil}

  public var protocolVersion: Int32 {
    get {return _protocolVersion ?? 0}
    set {_protocolVersion = newValue}
  }
  /// Returns true if `protocolVersion` has been explicitly set.
  public var hasProtocolVersion: Bool {return self._protocolVersion != nil}
  /// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
  public mutating func clearProtocolVersion() {self._protocolVersion = nil}

  public var maxMessageSize: Int32 {
    get {return _maxMessageSize ?? 0}
    set {_maxMessageSize = newValue}
  }
  /// Returns true if `maxMessageSize` has been explicitly set.
  public var hasMaxMessageSize: Bool {return self._maxMessageSize != nil}
  /// Clears the value of `maxMessageSize`. Subsequent reads from it will return its default value.
  public mutating func clearMaxMessageSize() {self._maxMessageSize = nil}

  public var featureFlags: Pulsar_Proto_FeatureFlags {
    get {return _featureFlags ?? Pulsar_Proto_FeatureFlags()}
    set {_featureFlags = newValue}
  }
  /// Returns true if `featureFlags` has been explicitly set.
  public var hasFeatureFlags: Bool {return self._featureFlags != nil}
  /// Clears the value of `featureFlags`. Subsequent reads from it will return its default value.
  public mutating func clearFeatureFlags() {self._featureFlags = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serverVersion: String? = nil
  fileprivate var _protocolVersion: Int32? = nil
  fileprivate var _maxMessageSize: Int32? = nil
  fileprivate var _featureFlags: Pulsar_Proto_FeatureFlags? = nil
}

public struct Pulsar_Proto_CommandAuthResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the client. Proxy should forward client's client_version.
  public var clientVersion: String {
    get {return _clientVersion ?? String()}
    set {_clientVersion = newValue}
  }
  /// Returns true if `clientVersion` has been explicitly set.
  public var hasClientVersion: Bool {return self._clientVersion != nil}
  /// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
  public mutating func clearClientVersion() {self._clientVersion = nil}

  public var response: Pulsar_Proto_AuthData {
    get {return _response ?? Pulsar_Proto_AuthData()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  public var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  public mutating func clearResponse() {self._response = nil}

  public var protocolVersion: Int32 {
    get {return _protocolVersion ?? 0}
    set {_protocolVersion = newValue}
  }
  /// Returns true if `protocolVersion` has been explicitly set.
  public var hasProtocolVersion: Bool {return self._protocolVersion != nil}
  /// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
  public mutating func clearProtocolVersion() {self._protocolVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientVersion: String? = nil
  fileprivate var _response: Pulsar_Proto_AuthData? = nil
  fileprivate var _protocolVersion: Int32? = nil
}

public struct Pulsar_Proto_CommandAuthChallenge: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverVersion: String {
    get {return _serverVersion ?? String()}
    set {_serverVersion = newValue}
  }
  /// Returns true if `serverVersion` has been explicitly set.
  public var hasServerVersion: Bool {return self._serverVersion != nil}
  /// Clears the value of `serverVersion`. Subsequent reads from it will return its default value.
  public mutating func clearServerVersion() {self._serverVersion = nil}

  public var challenge: Pulsar_Proto_AuthData {
    get {return _challenge ?? Pulsar_Proto_AuthData()}
    set {_challenge = newValue}
  }
  /// Returns true if `challenge` has been explicitly set.
  public var hasChallenge: Bool {return self._challenge != nil}
  /// Clears the value of `challenge`. Subsequent reads from it will return its default value.
  public mutating func clearChallenge() {self._challenge = nil}

  public var protocolVersion: Int32 {
    get {return _protocolVersion ?? 0}
    set {_protocolVersion = newValue}
  }
  /// Returns true if `protocolVersion` has been explicitly set.
  public var hasProtocolVersion: Bool {return self._protocolVersion != nil}
  /// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
  public mutating func clearProtocolVersion() {self._protocolVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serverVersion: String? = nil
  fileprivate var _challenge: Pulsar_Proto_AuthData? = nil
  fileprivate var _protocolVersion: Int32? = nil
}

/// To support mutual authentication type, such as Sasl, reuse this command to mutual auth.
public struct Pulsar_Proto_AuthData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authMethodName: String {
    get {return _authMethodName ?? String()}
    set {_authMethodName = newValue}
  }
  /// Returns true if `authMethodName` has been explicitly set.
  public var hasAuthMethodName: Bool {return self._authMethodName != nil}
  /// Clears the value of `authMethodName`. Subsequent reads from it will return its default value.
  public mutating func clearAuthMethodName() {self._authMethodName = nil}

  public var authData: Data {
    get {return _authData ?? Data()}
    set {_authData = newValue}
  }
  /// Returns true if `authData` has been explicitly set.
  public var hasAuthData: Bool {return self._authData != nil}
  /// Clears the value of `authData`. Subsequent reads from it will return its default value.
  public mutating func clearAuthData() {self._authData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authMethodName: String? = nil
  fileprivate var _authData: Data? = nil
}

public struct Pulsar_Proto_KeySharedMeta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keySharedMode: Pulsar_Proto_KeySharedMode {
    get {return _keySharedMode ?? .autoSplit}
    set {_keySharedMode = newValue}
  }
  /// Returns true if `keySharedMode` has been explicitly set.
  public var hasKeySharedMode: Bool {return self._keySharedMode != nil}
  /// Clears the value of `keySharedMode`. Subsequent reads from it will return its default value.
  public mutating func clearKeySharedMode() {self._keySharedMode = nil}

  public var hashRanges: [Pulsar_Proto_IntRange] = []

  public var allowOutOfOrderDelivery: Bool {
    get {return _allowOutOfOrderDelivery ?? false}
    set {_allowOutOfOrderDelivery = newValue}
  }
  /// Returns true if `allowOutOfOrderDelivery` has been explicitly set.
  public var hasAllowOutOfOrderDelivery: Bool {return self._allowOutOfOrderDelivery != nil}
  /// Clears the value of `allowOutOfOrderDelivery`. Subsequent reads from it will return its default value.
  public mutating func clearAllowOutOfOrderDelivery() {self._allowOutOfOrderDelivery = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keySharedMode: Pulsar_Proto_KeySharedMode? = nil
  fileprivate var _allowOutOfOrderDelivery: Bool? = nil
}

public struct Pulsar_Proto_CommandSubscribe: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String {
    get {return _storage._topic ?? String()}
    set {_uniqueStorage()._topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return _storage._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {_uniqueStorage()._topic = nil}

  public var subscription: String {
    get {return _storage._subscription ?? String()}
    set {_uniqueStorage()._subscription = newValue}
  }
  /// Returns true if `subscription` has been explicitly set.
  public var hasSubscription: Bool {return _storage._subscription != nil}
  /// Clears the value of `subscription`. Subsequent reads from it will return its default value.
  public mutating func clearSubscription() {_uniqueStorage()._subscription = nil}

  public var subType: Pulsar_Proto_CommandSubscribe.SubType {
    get {return _storage._subType ?? .exclusive}
    set {_uniqueStorage()._subType = newValue}
  }
  /// Returns true if `subType` has been explicitly set.
  public var hasSubType: Bool {return _storage._subType != nil}
  /// Clears the value of `subType`. Subsequent reads from it will return its default value.
  public mutating func clearSubType() {_uniqueStorage()._subType = nil}

  public var consumerID: UInt64 {
    get {return _storage._consumerID ?? 0}
    set {_uniqueStorage()._consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return _storage._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {_uniqueStorage()._consumerID = nil}

  public var requestID: UInt64 {
    get {return _storage._requestID ?? 0}
    set {_uniqueStorage()._requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return _storage._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {_uniqueStorage()._requestID = nil}

  public var consumerName: String {
    get {return _storage._consumerName ?? String()}
    set {_uniqueStorage()._consumerName = newValue}
  }
  /// Returns true if `consumerName` has been explicitly set.
  public var hasConsumerName: Bool {return _storage._consumerName != nil}
  /// Clears the value of `consumerName`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerName() {_uniqueStorage()._consumerName = nil}

  public var priorityLevel: Int32 {
    get {return _storage._priorityLevel ?? 0}
    set {_uniqueStorage()._priorityLevel = newValue}
  }
  /// Returns true if `priorityLevel` has been explicitly set.
  public var hasPriorityLevel: Bool {return _storage._priorityLevel != nil}
  /// Clears the value of `priorityLevel`. Subsequent reads from it will return its default value.
  public mutating func clearPriorityLevel() {_uniqueStorage()._priorityLevel = nil}

  /// Signal wether the subscription should be backed by a
  /// durable cursor or not
  public var durable: Bool {
    get {return _storage._durable ?? true}
    set {_uniqueStorage()._durable = newValue}
  }
  /// Returns true if `durable` has been explicitly set.
  public var hasDurable: Bool {return _storage._durable != nil}
  /// Clears the value of `durable`. Subsequent reads from it will return its default value.
  public mutating func clearDurable() {_uniqueStorage()._durable = nil}

  /// If specified, the subscription will position the cursor
  /// markd-delete position  on the particular message id and
  /// will send messages from that point
  public var startMessageID: Pulsar_Proto_MessageIdData {
    get {return _storage._startMessageID ?? Pulsar_Proto_MessageIdData()}
    set {_uniqueStorage()._startMessageID = newValue}
  }
  /// Returns true if `startMessageID` has been explicitly set.
  public var hasStartMessageID: Bool {return _storage._startMessageID != nil}
  /// Clears the value of `startMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearStartMessageID() {_uniqueStorage()._startMessageID = nil}

  //// Add optional metadata key=value to this consumer
  public var metadata: [Pulsar_Proto_KeyValue] {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  public var readCompacted: Bool {
    get {return _storage._readCompacted ?? false}
    set {_uniqueStorage()._readCompacted = newValue}
  }
  /// Returns true if `readCompacted` has been explicitly set.
  public var hasReadCompacted: Bool {return _storage._readCompacted != nil}
  /// Clears the value of `readCompacted`. Subsequent reads from it will return its default value.
  public mutating func clearReadCompacted() {_uniqueStorage()._readCompacted = nil}

  public var schema: Pulsar_Proto_Schema {
    get {return _storage._schema ?? Pulsar_Proto_Schema()}
    set {_uniqueStorage()._schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return _storage._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {_uniqueStorage()._schema = nil}

  /// Signal whether the subscription will initialize on latest
  /// or not -- earliest
  public var initialPosition: Pulsar_Proto_CommandSubscribe.InitialPosition {
    get {return _storage._initialPosition ?? .latest}
    set {_uniqueStorage()._initialPosition = newValue}
  }
  /// Returns true if `initialPosition` has been explicitly set.
  public var hasInitialPosition: Bool {return _storage._initialPosition != nil}
  /// Clears the value of `initialPosition`. Subsequent reads from it will return its default value.
  public mutating func clearInitialPosition() {_uniqueStorage()._initialPosition = nil}

  /// Mark the subscription as "replicated". Pulsar will make sure
  /// to periodically sync the state of replicated subscriptions
  /// across different clusters (when using geo-replication).
  public var replicateSubscriptionState: Bool {
    get {return _storage._replicateSubscriptionState ?? false}
    set {_uniqueStorage()._replicateSubscriptionState = newValue}
  }
  /// Returns true if `replicateSubscriptionState` has been explicitly set.
  public var hasReplicateSubscriptionState: Bool {return _storage._replicateSubscriptionState != nil}
  /// Clears the value of `replicateSubscriptionState`. Subsequent reads from it will return its default value.
  public mutating func clearReplicateSubscriptionState() {_uniqueStorage()._replicateSubscriptionState = nil}

  /// If true, the subscribe operation will cause a topic to be
  /// created if it does not exist already (and if topic auto-creation
  /// is allowed by broker.
  /// If false, the subscribe operation will fail if the topic
  /// does not exist.
  public var forceTopicCreation: Bool {
    get {return _storage._forceTopicCreation ?? true}
    set {_uniqueStorage()._forceTopicCreation = newValue}
  }
  /// Returns true if `forceTopicCreation` has been explicitly set.
  public var hasForceTopicCreation: Bool {return _storage._forceTopicCreation != nil}
  /// Clears the value of `forceTopicCreation`. Subsequent reads from it will return its default value.
  public mutating func clearForceTopicCreation() {_uniqueStorage()._forceTopicCreation = nil}

  /// If specified, the subscription will reset cursor's position back
  /// to specified seconds and  will send messages from that point
  public var startMessageRollbackDurationSec: UInt64 {
    get {return _storage._startMessageRollbackDurationSec ?? 0}
    set {_uniqueStorage()._startMessageRollbackDurationSec = newValue}
  }
  /// Returns true if `startMessageRollbackDurationSec` has been explicitly set.
  public var hasStartMessageRollbackDurationSec: Bool {return _storage._startMessageRollbackDurationSec != nil}
  /// Clears the value of `startMessageRollbackDurationSec`. Subsequent reads from it will return its default value.
  public mutating func clearStartMessageRollbackDurationSec() {_uniqueStorage()._startMessageRollbackDurationSec = nil}

  public var keySharedMeta: Pulsar_Proto_KeySharedMeta {
    get {return _storage._keySharedMeta ?? Pulsar_Proto_KeySharedMeta()}
    set {_uniqueStorage()._keySharedMeta = newValue}
  }
  /// Returns true if `keySharedMeta` has been explicitly set.
  public var hasKeySharedMeta: Bool {return _storage._keySharedMeta != nil}
  /// Clears the value of `keySharedMeta`. Subsequent reads from it will return its default value.
  public mutating func clearKeySharedMeta() {_uniqueStorage()._keySharedMeta = nil}

  public var subscriptionProperties: [Pulsar_Proto_KeyValue] {
    get {return _storage._subscriptionProperties}
    set {_uniqueStorage()._subscriptionProperties = newValue}
  }

  /// The consumer epoch, when exclusive and failover consumer redeliver unack message will increase the epoch
  public var consumerEpoch: UInt64 {
    get {return _storage._consumerEpoch ?? 0}
    set {_uniqueStorage()._consumerEpoch = newValue}
  }
  /// Returns true if `consumerEpoch` has been explicitly set.
  public var hasConsumerEpoch: Bool {return _storage._consumerEpoch != nil}
  /// Clears the value of `consumerEpoch`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerEpoch() {_uniqueStorage()._consumerEpoch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SubType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case exclusive = 0
    case shared = 1
    case failover = 2
    case keyShared = 3

    public init() {
      self = .exclusive
    }

  }

  public enum InitialPosition: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case latest = 0
    case earliest = 1

    public init() {
      self = .latest
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Pulsar_Proto_CommandPartitionedTopicMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  /// TODO - Remove original_principal, original_auth_data, original_auth_method
  /// Original principal that was verified by
  /// a Pulsar proxy.
  public var originalPrincipal: String {
    get {return _originalPrincipal ?? String()}
    set {_originalPrincipal = newValue}
  }
  /// Returns true if `originalPrincipal` has been explicitly set.
  public var hasOriginalPrincipal: Bool {return self._originalPrincipal != nil}
  /// Clears the value of `originalPrincipal`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalPrincipal() {self._originalPrincipal = nil}

  /// Original auth role and auth Method that was passed
  /// to the proxy.
  public var originalAuthData: String {
    get {return _originalAuthData ?? String()}
    set {_originalAuthData = newValue}
  }
  /// Returns true if `originalAuthData` has been explicitly set.
  public var hasOriginalAuthData: Bool {return self._originalAuthData != nil}
  /// Clears the value of `originalAuthData`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalAuthData() {self._originalAuthData = nil}

  public var originalAuthMethod: String {
    get {return _originalAuthMethod ?? String()}
    set {_originalAuthMethod = newValue}
  }
  /// Returns true if `originalAuthMethod` has been explicitly set.
  public var hasOriginalAuthMethod: Bool {return self._originalAuthMethod != nil}
  /// Clears the value of `originalAuthMethod`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalAuthMethod() {self._originalAuthMethod = nil}

  public var metadataAutoCreationEnabled: Bool {
    get {return _metadataAutoCreationEnabled ?? true}
    set {_metadataAutoCreationEnabled = newValue}
  }
  /// Returns true if `metadataAutoCreationEnabled` has been explicitly set.
  public var hasMetadataAutoCreationEnabled: Bool {return self._metadataAutoCreationEnabled != nil}
  /// Clears the value of `metadataAutoCreationEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataAutoCreationEnabled() {self._metadataAutoCreationEnabled = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topic: String? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _originalPrincipal: String? = nil
  fileprivate var _originalAuthData: String? = nil
  fileprivate var _originalAuthMethod: String? = nil
  fileprivate var _metadataAutoCreationEnabled: Bool? = nil
}

public struct Pulsar_Proto_CommandPartitionedTopicMetadataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional in case of error
  public var partitions: UInt32 {
    get {return _partitions ?? 0}
    set {_partitions = newValue}
  }
  /// Returns true if `partitions` has been explicitly set.
  public var hasPartitions: Bool {return self._partitions != nil}
  /// Clears the value of `partitions`. Subsequent reads from it will return its default value.
  public mutating func clearPartitions() {self._partitions = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var response: Pulsar_Proto_CommandPartitionedTopicMetadataResponse.LookupType {
    get {return _response ?? .success}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  public var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  public mutating func clearResponse() {self._response = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum LookupType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case success = 0
    case failed = 1

    public init() {
      self = .success
    }

  }

  public init() {}

  fileprivate var _partitions: UInt32? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _response: Pulsar_Proto_CommandPartitionedTopicMetadataResponse.LookupType? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_CommandLookupTopic: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var authoritative: Bool {
    get {return _authoritative ?? false}
    set {_authoritative = newValue}
  }
  /// Returns true if `authoritative` has been explicitly set.
  public var hasAuthoritative: Bool {return self._authoritative != nil}
  /// Clears the value of `authoritative`. Subsequent reads from it will return its default value.
  public mutating func clearAuthoritative() {self._authoritative = nil}

  /// TODO - Remove original_principal, original_auth_data, original_auth_method
  /// Original principal that was verified by
  /// a Pulsar proxy.
  public var originalPrincipal: String {
    get {return _originalPrincipal ?? String()}
    set {_originalPrincipal = newValue}
  }
  /// Returns true if `originalPrincipal` has been explicitly set.
  public var hasOriginalPrincipal: Bool {return self._originalPrincipal != nil}
  /// Clears the value of `originalPrincipal`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalPrincipal() {self._originalPrincipal = nil}

  /// Original auth role and auth Method that was passed
  /// to the proxy.
  public var originalAuthData: String {
    get {return _originalAuthData ?? String()}
    set {_originalAuthData = newValue}
  }
  /// Returns true if `originalAuthData` has been explicitly set.
  public var hasOriginalAuthData: Bool {return self._originalAuthData != nil}
  /// Clears the value of `originalAuthData`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalAuthData() {self._originalAuthData = nil}

  public var originalAuthMethod: String {
    get {return _originalAuthMethod ?? String()}
    set {_originalAuthMethod = newValue}
  }
  /// Returns true if `originalAuthMethod` has been explicitly set.
  public var hasOriginalAuthMethod: Bool {return self._originalAuthMethod != nil}
  /// Clears the value of `originalAuthMethod`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalAuthMethod() {self._originalAuthMethod = nil}

  public var advertisedListenerName: String {
    get {return _advertisedListenerName ?? String()}
    set {_advertisedListenerName = newValue}
  }
  /// Returns true if `advertisedListenerName` has been explicitly set.
  public var hasAdvertisedListenerName: Bool {return self._advertisedListenerName != nil}
  /// Clears the value of `advertisedListenerName`. Subsequent reads from it will return its default value.
  public mutating func clearAdvertisedListenerName() {self._advertisedListenerName = nil}

  /// The properties used for topic lookup
  public var properties: [Pulsar_Proto_KeyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topic: String? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _authoritative: Bool? = nil
  fileprivate var _originalPrincipal: String? = nil
  fileprivate var _originalAuthData: String? = nil
  fileprivate var _originalAuthMethod: String? = nil
  fileprivate var _advertisedListenerName: String? = nil
}

public struct Pulsar_Proto_CommandLookupTopicResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional in case of error
  public var brokerServiceURL: String {
    get {return _brokerServiceURL ?? String()}
    set {_brokerServiceURL = newValue}
  }
  /// Returns true if `brokerServiceURL` has been explicitly set.
  public var hasBrokerServiceURL: Bool {return self._brokerServiceURL != nil}
  /// Clears the value of `brokerServiceURL`. Subsequent reads from it will return its default value.
  public mutating func clearBrokerServiceURL() {self._brokerServiceURL = nil}

  public var brokerServiceURLTls: String {
    get {return _brokerServiceURLTls ?? String()}
    set {_brokerServiceURLTls = newValue}
  }
  /// Returns true if `brokerServiceURLTls` has been explicitly set.
  public var hasBrokerServiceURLTls: Bool {return self._brokerServiceURLTls != nil}
  /// Clears the value of `brokerServiceURLTls`. Subsequent reads from it will return its default value.
  public mutating func clearBrokerServiceURLTls() {self._brokerServiceURLTls = nil}

  public var response: Pulsar_Proto_CommandLookupTopicResponse.LookupType {
    get {return _response ?? .redirect}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  public var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  public mutating func clearResponse() {self._response = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var authoritative: Bool {
    get {return _authoritative ?? false}
    set {_authoritative = newValue}
  }
  /// Returns true if `authoritative` has been explicitly set.
  public var hasAuthoritative: Bool {return self._authoritative != nil}
  /// Clears the value of `authoritative`. Subsequent reads from it will return its default value.
  public mutating func clearAuthoritative() {self._authoritative = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  /// If it's true, indicates to the client that it must
  /// always connect through the service url after the
  /// lookup has been completed.
  public var proxyThroughServiceURL: Bool {
    get {return _proxyThroughServiceURL ?? false}
    set {_proxyThroughServiceURL = newValue}
  }
  /// Returns true if `proxyThroughServiceURL` has been explicitly set.
  public var hasProxyThroughServiceURL: Bool {return self._proxyThroughServiceURL != nil}
  /// Clears the value of `proxyThroughServiceURL`. Subsequent reads from it will return its default value.
  public mutating func clearProxyThroughServiceURL() {self._proxyThroughServiceURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum LookupType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case redirect = 0
    case connect = 1
    case failed = 2

    public init() {
      self = .redirect
    }

  }

  public init() {}

  fileprivate var _brokerServiceURL: String? = nil
  fileprivate var _brokerServiceURLTls: String? = nil
  fileprivate var _response: Pulsar_Proto_CommandLookupTopicResponse.LookupType? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _authoritative: Bool? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
  fileprivate var _proxyThroughServiceURL: Bool? = nil
}

//// Create a new Producer on a topic, assigning the given producer_id,
//// all messages sent with this producer_id will be persisted on the topic
public struct Pulsar_Proto_CommandProducer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var producerID: UInt64 {
    get {return _producerID ?? 0}
    set {_producerID = newValue}
  }
  /// Returns true if `producerID` has been explicitly set.
  public var hasProducerID: Bool {return self._producerID != nil}
  /// Clears the value of `producerID`. Subsequent reads from it will return its default value.
  public mutating func clearProducerID() {self._producerID = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  //// If a producer name is specified, the name will be used,
  //// otherwise the broker will generate a unique name
  public var producerName: String {
    get {return _producerName ?? String()}
    set {_producerName = newValue}
  }
  /// Returns true if `producerName` has been explicitly set.
  public var hasProducerName: Bool {return self._producerName != nil}
  /// Clears the value of `producerName`. Subsequent reads from it will return its default value.
  public mutating func clearProducerName() {self._producerName = nil}

  public var encrypted: Bool {
    get {return _encrypted ?? false}
    set {_encrypted = newValue}
  }
  /// Returns true if `encrypted` has been explicitly set.
  public var hasEncrypted: Bool {return self._encrypted != nil}
  /// Clears the value of `encrypted`. Subsequent reads from it will return its default value.
  public mutating func clearEncrypted() {self._encrypted = nil}

  //// Add optional metadata key=value to this producer
  public var metadata: [Pulsar_Proto_KeyValue] = []

  public var schema: Pulsar_Proto_Schema {
    get {return _schema ?? Pulsar_Proto_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  /// If producer reconnect to broker, the epoch of this producer will +1
  public var epoch: UInt64 {
    get {return _epoch ?? 0}
    set {_epoch = newValue}
  }
  /// Returns true if `epoch` has been explicitly set.
  public var hasEpoch: Bool {return self._epoch != nil}
  /// Clears the value of `epoch`. Subsequent reads from it will return its default value.
  public mutating func clearEpoch() {self._epoch = nil}

  /// Indicate the name of the producer is generated or user provided
  /// Use default true here is in order to be forward compatible with the client
  public var userProvidedProducerName: Bool {
    get {return _userProvidedProducerName ?? true}
    set {_userProvidedProducerName = newValue}
  }
  /// Returns true if `userProvidedProducerName` has been explicitly set.
  public var hasUserProvidedProducerName: Bool {return self._userProvidedProducerName != nil}
  /// Clears the value of `userProvidedProducerName`. Subsequent reads from it will return its default value.
  public mutating func clearUserProvidedProducerName() {self._userProvidedProducerName = nil}

  /// Require that this producers will be the only producer allowed on the topic
  public var producerAccessMode: Pulsar_Proto_ProducerAccessMode {
    get {return _producerAccessMode ?? .shared}
    set {_producerAccessMode = newValue}
  }
  /// Returns true if `producerAccessMode` has been explicitly set.
  public var hasProducerAccessMode: Bool {return self._producerAccessMode != nil}
  /// Clears the value of `producerAccessMode`. Subsequent reads from it will return its default value.
  public mutating func clearProducerAccessMode() {self._producerAccessMode = nil}

  /// Topic epoch is used to fence off producers that reconnects after a new
  /// exclusive producer has already taken over. This id is assigned by the
  /// broker on the CommandProducerSuccess. The first time, the client will
  /// leave it empty and then it will always carry the same epoch number on
  /// the subsequent reconnections.
  public var topicEpoch: UInt64 {
    get {return _topicEpoch ?? 0}
    set {_topicEpoch = newValue}
  }
  /// Returns true if `topicEpoch` has been explicitly set.
  public var hasTopicEpoch: Bool {return self._topicEpoch != nil}
  /// Clears the value of `topicEpoch`. Subsequent reads from it will return its default value.
  public mutating func clearTopicEpoch() {self._topicEpoch = nil}

  public var txnEnabled: Bool {
    get {return _txnEnabled ?? false}
    set {_txnEnabled = newValue}
  }
  /// Returns true if `txnEnabled` has been explicitly set.
  public var hasTxnEnabled: Bool {return self._txnEnabled != nil}
  /// Clears the value of `txnEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearTxnEnabled() {self._txnEnabled = nil}

  /// Name of the initial subscription of the topic.
  /// If this field is not set, the initial subscription will not be created.
  /// If this field is set but the broker's `allowAutoSubscriptionCreation`
  /// is disabled, the producer will fail to be created.
  public var initialSubscriptionName: String {
    get {return _initialSubscriptionName ?? String()}
    set {_initialSubscriptionName = newValue}
  }
  /// Returns true if `initialSubscriptionName` has been explicitly set.
  public var hasInitialSubscriptionName: Bool {return self._initialSubscriptionName != nil}
  /// Clears the value of `initialSubscriptionName`. Subsequent reads from it will return its default value.
  public mutating func clearInitialSubscriptionName() {self._initialSubscriptionName = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topic: String? = nil
  fileprivate var _producerID: UInt64? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _producerName: String? = nil
  fileprivate var _encrypted: Bool? = nil
  fileprivate var _schema: Pulsar_Proto_Schema? = nil
  fileprivate var _epoch: UInt64? = nil
  fileprivate var _userProvidedProducerName: Bool? = nil
  fileprivate var _producerAccessMode: Pulsar_Proto_ProducerAccessMode? = nil
  fileprivate var _topicEpoch: UInt64? = nil
  fileprivate var _txnEnabled: Bool? = nil
  fileprivate var _initialSubscriptionName: String? = nil
}

public struct Pulsar_Proto_CommandSend: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var producerID: UInt64 {
    get {return _producerID ?? 0}
    set {_producerID = newValue}
  }
  /// Returns true if `producerID` has been explicitly set.
  public var hasProducerID: Bool {return self._producerID != nil}
  /// Clears the value of `producerID`. Subsequent reads from it will return its default value.
  public mutating func clearProducerID() {self._producerID = nil}

  public var sequenceID: UInt64 {
    get {return _sequenceID ?? 0}
    set {_sequenceID = newValue}
  }
  /// Returns true if `sequenceID` has been explicitly set.
  public var hasSequenceID: Bool {return self._sequenceID != nil}
  /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearSequenceID() {self._sequenceID = nil}

  public var numMessages: Int32 {
    get {return _numMessages ?? 1}
    set {_numMessages = newValue}
  }
  /// Returns true if `numMessages` has been explicitly set.
  public var hasNumMessages: Bool {return self._numMessages != nil}
  /// Clears the value of `numMessages`. Subsequent reads from it will return its default value.
  public mutating func clearNumMessages() {self._numMessages = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  //// Add highest sequence id to support batch message with external sequence id
  public var highestSequenceID: UInt64 {
    get {return _highestSequenceID ?? 0}
    set {_highestSequenceID = newValue}
  }
  /// Returns true if `highestSequenceID` has been explicitly set.
  public var hasHighestSequenceID: Bool {return self._highestSequenceID != nil}
  /// Clears the value of `highestSequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearHighestSequenceID() {self._highestSequenceID = nil}

  public var isChunk: Bool {
    get {return _isChunk ?? false}
    set {_isChunk = newValue}
  }
  /// Returns true if `isChunk` has been explicitly set.
  public var hasIsChunk: Bool {return self._isChunk != nil}
  /// Clears the value of `isChunk`. Subsequent reads from it will return its default value.
  public mutating func clearIsChunk() {self._isChunk = nil}

  /// Specify if the message being published is a Pulsar marker or not
  public var marker: Bool {
    get {return _marker ?? false}
    set {_marker = newValue}
  }
  /// Returns true if `marker` has been explicitly set.
  public var hasMarker: Bool {return self._marker != nil}
  /// Clears the value of `marker`. Subsequent reads from it will return its default value.
  public mutating func clearMarker() {self._marker = nil}

  /// Message id of this message, currently is used in replicator for shadow topic.
  public var messageID: Pulsar_Proto_MessageIdData {
    get {return _messageID ?? Pulsar_Proto_MessageIdData()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _producerID: UInt64? = nil
  fileprivate var _sequenceID: UInt64? = nil
  fileprivate var _numMessages: Int32? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _highestSequenceID: UInt64? = nil
  fileprivate var _isChunk: Bool? = nil
  fileprivate var _marker: Bool? = nil
  fileprivate var _messageID: Pulsar_Proto_MessageIdData? = nil
}

public struct Pulsar_Proto_CommandSendReceipt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var producerID: UInt64 {
    get {return _producerID ?? 0}
    set {_producerID = newValue}
  }
  /// Returns true if `producerID` has been explicitly set.
  public var hasProducerID: Bool {return self._producerID != nil}
  /// Clears the value of `producerID`. Subsequent reads from it will return its default value.
  public mutating func clearProducerID() {self._producerID = nil}

  public var sequenceID: UInt64 {
    get {return _sequenceID ?? 0}
    set {_sequenceID = newValue}
  }
  /// Returns true if `sequenceID` has been explicitly set.
  public var hasSequenceID: Bool {return self._sequenceID != nil}
  /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearSequenceID() {self._sequenceID = nil}

  public var messageID: Pulsar_Proto_MessageIdData {
    get {return _messageID ?? Pulsar_Proto_MessageIdData()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var highestSequenceID: UInt64 {
    get {return _highestSequenceID ?? 0}
    set {_highestSequenceID = newValue}
  }
  /// Returns true if `highestSequenceID` has been explicitly set.
  public var hasHighestSequenceID: Bool {return self._highestSequenceID != nil}
  /// Clears the value of `highestSequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearHighestSequenceID() {self._highestSequenceID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _producerID: UInt64? = nil
  fileprivate var _sequenceID: UInt64? = nil
  fileprivate var _messageID: Pulsar_Proto_MessageIdData? = nil
  fileprivate var _highestSequenceID: UInt64? = nil
}

public struct Pulsar_Proto_CommandSendError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var producerID: UInt64 {
    get {return _producerID ?? 0}
    set {_producerID = newValue}
  }
  /// Returns true if `producerID` has been explicitly set.
  public var hasProducerID: Bool {return self._producerID != nil}
  /// Clears the value of `producerID`. Subsequent reads from it will return its default value.
  public mutating func clearProducerID() {self._producerID = nil}

  public var sequenceID: UInt64 {
    get {return _sequenceID ?? 0}
    set {_sequenceID = newValue}
  }
  /// Returns true if `sequenceID` has been explicitly set.
  public var hasSequenceID: Bool {return self._sequenceID != nil}
  /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearSequenceID() {self._sequenceID = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _producerID: UInt64? = nil
  fileprivate var _sequenceID: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_CommandMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var messageID: Pulsar_Proto_MessageIdData {
    get {return _messageID ?? Pulsar_Proto_MessageIdData()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var redeliveryCount: UInt32 {
    get {return _redeliveryCount ?? 0}
    set {_redeliveryCount = newValue}
  }
  /// Returns true if `redeliveryCount` has been explicitly set.
  public var hasRedeliveryCount: Bool {return self._redeliveryCount != nil}
  /// Clears the value of `redeliveryCount`. Subsequent reads from it will return its default value.
  public mutating func clearRedeliveryCount() {self._redeliveryCount = nil}

  public var ackSet: [Int64] = []

  public var consumerEpoch: UInt64 {
    get {return _consumerEpoch ?? 0}
    set {_consumerEpoch = newValue}
  }
  /// Returns true if `consumerEpoch` has been explicitly set.
  public var hasConsumerEpoch: Bool {return self._consumerEpoch != nil}
  /// Clears the value of `consumerEpoch`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerEpoch() {self._consumerEpoch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _messageID: Pulsar_Proto_MessageIdData? = nil
  fileprivate var _redeliveryCount: UInt32? = nil
  fileprivate var _consumerEpoch: UInt64? = nil
}

public struct Pulsar_Proto_CommandAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var ackType: Pulsar_Proto_CommandAck.AckType {
    get {return _ackType ?? .individual}
    set {_ackType = newValue}
  }
  /// Returns true if `ackType` has been explicitly set.
  public var hasAckType: Bool {return self._ackType != nil}
  /// Clears the value of `ackType`. Subsequent reads from it will return its default value.
  public mutating func clearAckType() {self._ackType = nil}

  /// In case of individual acks, the client can pass a list of message ids
  public var messageID: [Pulsar_Proto_MessageIdData] = []

  public var validationError: Pulsar_Proto_CommandAck.ValidationError {
    get {return _validationError ?? .uncompressedSizeCorruption}
    set {_validationError = newValue}
  }
  /// Returns true if `validationError` has been explicitly set.
  public var hasValidationError: Bool {return self._validationError != nil}
  /// Clears the value of `validationError`. Subsequent reads from it will return its default value.
  public mutating func clearValidationError() {self._validationError = nil}

  public var properties: [Pulsar_Proto_KeyLongValue] = []

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AckType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case individual = 0
    case cumulative = 1

    public init() {
      self = .individual
    }

  }

  /// Acks can contain a flag to indicate the consumer
  /// received an invalid message that got discarded
  /// before being passed on to the application.
  public enum ValidationError: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case uncompressedSizeCorruption = 0
    case decompressionError = 1
    case checksumMismatch = 2
    case batchDeSerializeError = 3
    case decryptionError = 4

    public init() {
      self = .uncompressedSizeCorruption
    }

  }

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _ackType: Pulsar_Proto_CommandAck.AckType? = nil
  fileprivate var _validationError: Pulsar_Proto_CommandAck.ValidationError? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _requestID: UInt64? = nil
}

public struct Pulsar_Proto_CommandAckResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
  fileprivate var _requestID: UInt64? = nil
}

/// changes on active consumer
public struct Pulsar_Proto_CommandActiveConsumerChange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var isActive: Bool {
    get {return _isActive ?? false}
    set {_isActive = newValue}
  }
  /// Returns true if `isActive` has been explicitly set.
  public var hasIsActive: Bool {return self._isActive != nil}
  /// Clears the value of `isActive`. Subsequent reads from it will return its default value.
  public mutating func clearIsActive() {self._isActive = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _isActive: Bool? = nil
}

public struct Pulsar_Proto_CommandFlow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  /// Max number of messages to prefetch, in addition
  /// of any number previously specified
  public var messagePermits: UInt32 {
    get {return _messagePermits ?? 0}
    set {_messagePermits = newValue}
  }
  /// Returns true if `messagePermits` has been explicitly set.
  public var hasMessagePermits: Bool {return self._messagePermits != nil}
  /// Clears the value of `messagePermits`. Subsequent reads from it will return its default value.
  public mutating func clearMessagePermits() {self._messagePermits = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _messagePermits: UInt32? = nil
}

public struct Pulsar_Proto_CommandUnsubscribe: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var force: Bool {
    get {return _force ?? false}
    set {_force = newValue}
  }
  /// Returns true if `force` has been explicitly set.
  public var hasForce: Bool {return self._force != nil}
  /// Clears the value of `force`. Subsequent reads from it will return its default value.
  public mutating func clearForce() {self._force = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _force: Bool? = nil
}

/// Reset an existing consumer to a particular message id
public struct Pulsar_Proto_CommandSeek: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var messageID: Pulsar_Proto_MessageIdData {
    get {return _messageID ?? Pulsar_Proto_MessageIdData()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  public var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  public mutating func clearMessageID() {self._messageID = nil}

  public var messagePublishTime: UInt64 {
    get {return _messagePublishTime ?? 0}
    set {_messagePublishTime = newValue}
  }
  /// Returns true if `messagePublishTime` has been explicitly set.
  public var hasMessagePublishTime: Bool {return self._messagePublishTime != nil}
  /// Clears the value of `messagePublishTime`. Subsequent reads from it will return its default value.
  public mutating func clearMessagePublishTime() {self._messagePublishTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _messageID: Pulsar_Proto_MessageIdData? = nil
  fileprivate var _messagePublishTime: UInt64? = nil
}

/// Message sent by broker to client when a topic
/// has been forcefully terminated and there are no more
/// messages left to consume
public struct Pulsar_Proto_CommandReachedEndOfTopic: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
}

public struct Pulsar_Proto_CommandTopicMigrated: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resourceID: UInt64 {
    get {return _resourceID ?? 0}
    set {_resourceID = newValue}
  }
  /// Returns true if `resourceID` has been explicitly set.
  public var hasResourceID: Bool {return self._resourceID != nil}
  /// Clears the value of `resourceID`. Subsequent reads from it will return its default value.
  public mutating func clearResourceID() {self._resourceID = nil}

  public var resourceType: Pulsar_Proto_CommandTopicMigrated.ResourceType {
    get {return _resourceType ?? .producer}
    set {_resourceType = newValue}
  }
  /// Returns true if `resourceType` has been explicitly set.
  public var hasResourceType: Bool {return self._resourceType != nil}
  /// Clears the value of `resourceType`. Subsequent reads from it will return its default value.
  public mutating func clearResourceType() {self._resourceType = nil}

  public var brokerServiceURL: String {
    get {return _brokerServiceURL ?? String()}
    set {_brokerServiceURL = newValue}
  }
  /// Returns true if `brokerServiceURL` has been explicitly set.
  public var hasBrokerServiceURL: Bool {return self._brokerServiceURL != nil}
  /// Clears the value of `brokerServiceURL`. Subsequent reads from it will return its default value.
  public mutating func clearBrokerServiceURL() {self._brokerServiceURL = nil}

  public var brokerServiceURLTls: String {
    get {return _brokerServiceURLTls ?? String()}
    set {_brokerServiceURLTls = newValue}
  }
  /// Returns true if `brokerServiceURLTls` has been explicitly set.
  public var hasBrokerServiceURLTls: Bool {return self._brokerServiceURLTls != nil}
  /// Clears the value of `brokerServiceURLTls`. Subsequent reads from it will return its default value.
  public mutating func clearBrokerServiceURLTls() {self._brokerServiceURLTls = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ResourceType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case producer = 0
    case consumer = 1

    public init() {
      self = .producer
    }

  }

  public init() {}

  fileprivate var _resourceID: UInt64? = nil
  fileprivate var _resourceType: Pulsar_Proto_CommandTopicMigrated.ResourceType? = nil
  fileprivate var _brokerServiceURL: String? = nil
  fileprivate var _brokerServiceURLTls: String? = nil
}

public struct Pulsar_Proto_CommandCloseProducer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var producerID: UInt64 {
    get {return _producerID ?? 0}
    set {_producerID = newValue}
  }
  /// Returns true if `producerID` has been explicitly set.
  public var hasProducerID: Bool {return self._producerID != nil}
  /// Clears the value of `producerID`. Subsequent reads from it will return its default value.
  public mutating func clearProducerID() {self._producerID = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var assignedBrokerServiceURL: String {
    get {return _assignedBrokerServiceURL ?? String()}
    set {_assignedBrokerServiceURL = newValue}
  }
  /// Returns true if `assignedBrokerServiceURL` has been explicitly set.
  public var hasAssignedBrokerServiceURL: Bool {return self._assignedBrokerServiceURL != nil}
  /// Clears the value of `assignedBrokerServiceURL`. Subsequent reads from it will return its default value.
  public mutating func clearAssignedBrokerServiceURL() {self._assignedBrokerServiceURL = nil}

  public var assignedBrokerServiceURLTls: String {
    get {return _assignedBrokerServiceURLTls ?? String()}
    set {_assignedBrokerServiceURLTls = newValue}
  }
  /// Returns true if `assignedBrokerServiceURLTls` has been explicitly set.
  public var hasAssignedBrokerServiceURLTls: Bool {return self._assignedBrokerServiceURLTls != nil}
  /// Clears the value of `assignedBrokerServiceURLTls`. Subsequent reads from it will return its default value.
  public mutating func clearAssignedBrokerServiceURLTls() {self._assignedBrokerServiceURLTls = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _producerID: UInt64? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _assignedBrokerServiceURL: String? = nil
  fileprivate var _assignedBrokerServiceURLTls: String? = nil
}

public struct Pulsar_Proto_CommandCloseConsumer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var assignedBrokerServiceURL: String {
    get {return _assignedBrokerServiceURL ?? String()}
    set {_assignedBrokerServiceURL = newValue}
  }
  /// Returns true if `assignedBrokerServiceURL` has been explicitly set.
  public var hasAssignedBrokerServiceURL: Bool {return self._assignedBrokerServiceURL != nil}
  /// Clears the value of `assignedBrokerServiceURL`. Subsequent reads from it will return its default value.
  public mutating func clearAssignedBrokerServiceURL() {self._assignedBrokerServiceURL = nil}

  public var assignedBrokerServiceURLTls: String {
    get {return _assignedBrokerServiceURLTls ?? String()}
    set {_assignedBrokerServiceURLTls = newValue}
  }
  /// Returns true if `assignedBrokerServiceURLTls` has been explicitly set.
  public var hasAssignedBrokerServiceURLTls: Bool {return self._assignedBrokerServiceURLTls != nil}
  /// Clears the value of `assignedBrokerServiceURLTls`. Subsequent reads from it will return its default value.
  public mutating func clearAssignedBrokerServiceURLTls() {self._assignedBrokerServiceURLTls = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _assignedBrokerServiceURL: String? = nil
  fileprivate var _assignedBrokerServiceURLTls: String? = nil
}

public struct Pulsar_Proto_CommandRedeliverUnacknowledgedMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var messageIds: [Pulsar_Proto_MessageIdData] = []

  public var consumerEpoch: UInt64 {
    get {return _consumerEpoch ?? 0}
    set {_consumerEpoch = newValue}
  }
  /// Returns true if `consumerEpoch` has been explicitly set.
  public var hasConsumerEpoch: Bool {return self._consumerEpoch != nil}
  /// Clears the value of `consumerEpoch`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerEpoch() {self._consumerEpoch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _consumerEpoch: UInt64? = nil
}

public struct Pulsar_Proto_CommandSuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var schema: Pulsar_Proto_Schema {
    get {return _schema ?? Pulsar_Proto_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _schema: Pulsar_Proto_Schema? = nil
}

//// Response from CommandProducer
public struct Pulsar_Proto_CommandProducerSuccess: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var producerName: String {
    get {return _producerName ?? String()}
    set {_producerName = newValue}
  }
  /// Returns true if `producerName` has been explicitly set.
  public var hasProducerName: Bool {return self._producerName != nil}
  /// Clears the value of `producerName`. Subsequent reads from it will return its default value.
  public mutating func clearProducerName() {self._producerName = nil}

  /// The last sequence id that was stored by this producer in the previous session
  /// This will only be meaningful if deduplication has been enabled.
  public var lastSequenceID: Int64 {
    get {return _lastSequenceID ?? -1}
    set {_lastSequenceID = newValue}
  }
  /// Returns true if `lastSequenceID` has been explicitly set.
  public var hasLastSequenceID: Bool {return self._lastSequenceID != nil}
  /// Clears the value of `lastSequenceID`. Subsequent reads from it will return its default value.
  public mutating func clearLastSequenceID() {self._lastSequenceID = nil}

  public var schemaVersion: Data {
    get {return _schemaVersion ?? Data()}
    set {_schemaVersion = newValue}
  }
  /// Returns true if `schemaVersion` has been explicitly set.
  public var hasSchemaVersion: Bool {return self._schemaVersion != nil}
  /// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSchemaVersion() {self._schemaVersion = nil}

  /// The topic epoch assigned by the broker. This field will only be set if we
  /// were requiring exclusive access when creating the producer.
  public var topicEpoch: UInt64 {
    get {return _topicEpoch ?? 0}
    set {_topicEpoch = newValue}
  }
  /// Returns true if `topicEpoch` has been explicitly set.
  public var hasTopicEpoch: Bool {return self._topicEpoch != nil}
  /// Clears the value of `topicEpoch`. Subsequent reads from it will return its default value.
  public mutating func clearTopicEpoch() {self._topicEpoch = nil}

  /// If producer is not "ready", the client will avoid to timeout the request
  /// for creating the producer. Instead it will wait indefinitely until it gets
  /// a subsequent  `CommandProducerSuccess` with `producer_ready==true`.
  public var producerReady: Bool {
    get {return _producerReady ?? true}
    set {_producerReady = newValue}
  }
  /// Returns true if `producerReady` has been explicitly set.
  public var hasProducerReady: Bool {return self._producerReady != nil}
  /// Clears the value of `producerReady`. Subsequent reads from it will return its default value.
  public mutating func clearProducerReady() {self._producerReady = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _producerName: String? = nil
  fileprivate var _lastSequenceID: Int64? = nil
  fileprivate var _schemaVersion: Data? = nil
  fileprivate var _topicEpoch: UInt64? = nil
  fileprivate var _producerReady: Bool? = nil
}

public struct Pulsar_Proto_CommandError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

/// Commands to probe the state of connection.
/// When either client or broker doesn't receive commands for certain
/// amount of time, they will send a Ping probe.
public struct Pulsar_Proto_CommandPing: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pulsar_Proto_CommandPong: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pulsar_Proto_CommandConsumerStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  /// required string topic_name         = 2;
  /// required string subscription_name  = 3;
  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _consumerID: UInt64? = nil
}

public struct Pulsar_Proto_CommandConsumerStatsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var errorCode: Pulsar_Proto_ServerError {
    get {return _errorCode ?? .unknownError}
    set {_errorCode = newValue}
  }
  /// Returns true if `errorCode` has been explicitly set.
  public var hasErrorCode: Bool {return self._errorCode != nil}
  /// Clears the value of `errorCode`. Subsequent reads from it will return its default value.
  public mutating func clearErrorCode() {self._errorCode = nil}

  public var errorMessage: String {
    get {return _errorMessage ?? String()}
    set {_errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  public var hasErrorMessage: Bool {return self._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  public mutating func clearErrorMessage() {self._errorMessage = nil}

  //// Total rate of messages delivered to the consumer. msg/s
  public var msgRateOut: Double {
    get {return _msgRateOut ?? 0}
    set {_msgRateOut = newValue}
  }
  /// Returns true if `msgRateOut` has been explicitly set.
  public var hasMsgRateOut: Bool {return self._msgRateOut != nil}
  /// Clears the value of `msgRateOut`. Subsequent reads from it will return its default value.
  public mutating func clearMsgRateOut() {self._msgRateOut = nil}

  //// Total throughput delivered to the consumer. bytes/s
  public var msgThroughputOut: Double {
    get {return _msgThroughputOut ?? 0}
    set {_msgThroughputOut = newValue}
  }
  /// Returns true if `msgThroughputOut` has been explicitly set.
  public var hasMsgThroughputOut: Bool {return self._msgThroughputOut != nil}
  /// Clears the value of `msgThroughputOut`. Subsequent reads from it will return its default value.
  public mutating func clearMsgThroughputOut() {self._msgThroughputOut = nil}

  //// Total rate of messages redelivered by this consumer. msg/s
  public var msgRateRedeliver: Double {
    get {return _msgRateRedeliver ?? 0}
    set {_msgRateRedeliver = newValue}
  }
  /// Returns true if `msgRateRedeliver` has been explicitly set.
  public var hasMsgRateRedeliver: Bool {return self._msgRateRedeliver != nil}
  /// Clears the value of `msgRateRedeliver`. Subsequent reads from it will return its default value.
  public mutating func clearMsgRateRedeliver() {self._msgRateRedeliver = nil}

  //// Name of the consumer
  public var consumerName: String {
    get {return _consumerName ?? String()}
    set {_consumerName = newValue}
  }
  /// Returns true if `consumerName` has been explicitly set.
  public var hasConsumerName: Bool {return self._consumerName != nil}
  /// Clears the value of `consumerName`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerName() {self._consumerName = nil}

  //// Number of available message permits for the consumer
  public var availablePermits: UInt64 {
    get {return _availablePermits ?? 0}
    set {_availablePermits = newValue}
  }
  /// Returns true if `availablePermits` has been explicitly set.
  public var hasAvailablePermits: Bool {return self._availablePermits != nil}
  /// Clears the value of `availablePermits`. Subsequent reads from it will return its default value.
  public mutating func clearAvailablePermits() {self._availablePermits = nil}

  //// Number of unacknowledged messages for the consumer
  public var unackedMessages: UInt64 {
    get {return _unackedMessages ?? 0}
    set {_unackedMessages = newValue}
  }
  /// Returns true if `unackedMessages` has been explicitly set.
  public var hasUnackedMessages: Bool {return self._unackedMessages != nil}
  /// Clears the value of `unackedMessages`. Subsequent reads from it will return its default value.
  public mutating func clearUnackedMessages() {self._unackedMessages = nil}

  //// Flag to verify if consumer is blocked due to reaching threshold of unacked messages
  public var blockedConsumerOnUnackedMsgs: Bool {
    get {return _blockedConsumerOnUnackedMsgs ?? false}
    set {_blockedConsumerOnUnackedMsgs = newValue}
  }
  /// Returns true if `blockedConsumerOnUnackedMsgs` has been explicitly set.
  public var hasBlockedConsumerOnUnackedMsgs: Bool {return self._blockedConsumerOnUnackedMsgs != nil}
  /// Clears the value of `blockedConsumerOnUnackedMsgs`. Subsequent reads from it will return its default value.
  public mutating func clearBlockedConsumerOnUnackedMsgs() {self._blockedConsumerOnUnackedMsgs = nil}

  //// Address of this consumer
  public var address: String {
    get {return _address ?? String()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  //// Timestamp of connection
  public var connectedSince: String {
    get {return _connectedSince ?? String()}
    set {_connectedSince = newValue}
  }
  /// Returns true if `connectedSince` has been explicitly set.
  public var hasConnectedSince: Bool {return self._connectedSince != nil}
  /// Clears the value of `connectedSince`. Subsequent reads from it will return its default value.
  public mutating func clearConnectedSince() {self._connectedSince = nil}

  //// Whether this subscription is Exclusive or Shared or Failover
  public var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  //// Total rate of messages expired on this subscription. msg/s
  public var msgRateExpired: Double {
    get {return _msgRateExpired ?? 0}
    set {_msgRateExpired = newValue}
  }
  /// Returns true if `msgRateExpired` has been explicitly set.
  public var hasMsgRateExpired: Bool {return self._msgRateExpired != nil}
  /// Clears the value of `msgRateExpired`. Subsequent reads from it will return its default value.
  public mutating func clearMsgRateExpired() {self._msgRateExpired = nil}

  //// Number of messages in the subscription backlog
  public var msgBacklog: UInt64 {
    get {return _msgBacklog ?? 0}
    set {_msgBacklog = newValue}
  }
  /// Returns true if `msgBacklog` has been explicitly set.
  public var hasMsgBacklog: Bool {return self._msgBacklog != nil}
  /// Clears the value of `msgBacklog`. Subsequent reads from it will return its default value.
  public mutating func clearMsgBacklog() {self._msgBacklog = nil}

  //// Total rate of messages ack. msg/s
  public var messageAckRate: Double {
    get {return _messageAckRate ?? 0}
    set {_messageAckRate = newValue}
  }
  /// Returns true if `messageAckRate` has been explicitly set.
  public var hasMessageAckRate: Bool {return self._messageAckRate != nil}
  /// Clears the value of `messageAckRate`. Subsequent reads from it will return its default value.
  public mutating func clearMessageAckRate() {self._messageAckRate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _errorCode: Pulsar_Proto_ServerError? = nil
  fileprivate var _errorMessage: String? = nil
  fileprivate var _msgRateOut: Double? = nil
  fileprivate var _msgThroughputOut: Double? = nil
  fileprivate var _msgRateRedeliver: Double? = nil
  fileprivate var _consumerName: String? = nil
  fileprivate var _availablePermits: UInt64? = nil
  fileprivate var _unackedMessages: UInt64? = nil
  fileprivate var _blockedConsumerOnUnackedMsgs: Bool? = nil
  fileprivate var _address: String? = nil
  fileprivate var _connectedSince: String? = nil
  fileprivate var _type: String? = nil
  fileprivate var _msgRateExpired: Double? = nil
  fileprivate var _msgBacklog: UInt64? = nil
  fileprivate var _messageAckRate: Double? = nil
}

public struct Pulsar_Proto_CommandGetLastMessageId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consumerID: UInt64 {
    get {return _consumerID ?? 0}
    set {_consumerID = newValue}
  }
  /// Returns true if `consumerID` has been explicitly set.
  public var hasConsumerID: Bool {return self._consumerID != nil}
  /// Clears the value of `consumerID`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerID() {self._consumerID = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _consumerID: UInt64? = nil
  fileprivate var _requestID: UInt64? = nil
}

public struct Pulsar_Proto_CommandGetLastMessageIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastMessageID: Pulsar_Proto_MessageIdData {
    get {return _lastMessageID ?? Pulsar_Proto_MessageIdData()}
    set {_lastMessageID = newValue}
  }
  /// Returns true if `lastMessageID` has been explicitly set.
  public var hasLastMessageID: Bool {return self._lastMessageID != nil}
  /// Clears the value of `lastMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearLastMessageID() {self._lastMessageID = nil}

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var consumerMarkDeletePosition: Pulsar_Proto_MessageIdData {
    get {return _consumerMarkDeletePosition ?? Pulsar_Proto_MessageIdData()}
    set {_consumerMarkDeletePosition = newValue}
  }
  /// Returns true if `consumerMarkDeletePosition` has been explicitly set.
  public var hasConsumerMarkDeletePosition: Bool {return self._consumerMarkDeletePosition != nil}
  /// Clears the value of `consumerMarkDeletePosition`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerMarkDeletePosition() {self._consumerMarkDeletePosition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastMessageID: Pulsar_Proto_MessageIdData? = nil
  fileprivate var _requestID: UInt64? = nil
  fileprivate var _consumerMarkDeletePosition: Pulsar_Proto_MessageIdData? = nil
}

public struct Pulsar_Proto_CommandGetTopicsOfNamespace: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var namespace: String {
    get {return _namespace ?? String()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  public var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  public mutating func clearNamespace() {self._namespace = nil}

  public var mode: Pulsar_Proto_CommandGetTopicsOfNamespace.Mode {
    get {return _mode ?? .persistent}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  public var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  public mutating func clearMode() {self._mode = nil}

  public var topicsPattern: String {
    get {return _topicsPattern ?? String()}
    set {_topicsPattern = newValue}
  }
  /// Returns true if `topicsPattern` has been explicitly set.
  public var hasTopicsPattern: Bool {return self._topicsPattern != nil}
  /// Clears the value of `topicsPattern`. Subsequent reads from it will return its default value.
  public mutating func clearTopicsPattern() {self._topicsPattern = nil}

  public var topicsHash: String {
    get {return _topicsHash ?? String()}
    set {_topicsHash = newValue}
  }
  /// Returns true if `topicsHash` has been explicitly set.
  public var hasTopicsHash: Bool {return self._topicsHash != nil}
  /// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
  public mutating func clearTopicsHash() {self._topicsHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Mode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case persistent = 0
    case nonPersistent = 1
    case all = 2

    public init() {
      self = .persistent
    }

  }

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _namespace: String? = nil
  fileprivate var _mode: Pulsar_Proto_CommandGetTopicsOfNamespace.Mode? = nil
  fileprivate var _topicsPattern: String? = nil
  fileprivate var _topicsHash: String? = nil
}

public struct Pulsar_Proto_CommandGetTopicsOfNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var topics: [String] = []

  /// true iff the topic list was filtered by the pattern supplied by the client
  public var filtered: Bool {
    get {return _filtered ?? false}
    set {_filtered = newValue}
  }
  /// Returns true if `filtered` has been explicitly set.
  public var hasFiltered: Bool {return self._filtered != nil}
  /// Clears the value of `filtered`. Subsequent reads from it will return its default value.
  public mutating func clearFiltered() {self._filtered = nil}

  /// hash computed from the names of matching topics
  public var topicsHash: String {
    get {return _topicsHash ?? String()}
    set {_topicsHash = newValue}
  }
  /// Returns true if `topicsHash` has been explicitly set.
  public var hasTopicsHash: Bool {return self._topicsHash != nil}
  /// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
  public mutating func clearTopicsHash() {self._topicsHash = nil}

  /// if false, topics is empty and the list of matching topics has not changed
  public var changed: Bool {
    get {return _changed ?? true}
    set {_changed = newValue}
  }
  /// Returns true if `changed` has been explicitly set.
  public var hasChanged: Bool {return self._changed != nil}
  /// Clears the value of `changed`. Subsequent reads from it will return its default value.
  public mutating func clearChanged() {self._changed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _filtered: Bool? = nil
  fileprivate var _topicsHash: String? = nil
  fileprivate var _changed: Bool? = nil
}

public struct Pulsar_Proto_CommandWatchTopicList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var watcherID: UInt64 {
    get {return _watcherID ?? 0}
    set {_watcherID = newValue}
  }
  /// Returns true if `watcherID` has been explicitly set.
  public var hasWatcherID: Bool {return self._watcherID != nil}
  /// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
  public mutating func clearWatcherID() {self._watcherID = nil}

  public var namespace: String {
    get {return _namespace ?? String()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  public var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  public mutating func clearNamespace() {self._namespace = nil}

  public var topicsPattern: String {
    get {return _topicsPattern ?? String()}
    set {_topicsPattern = newValue}
  }
  /// Returns true if `topicsPattern` has been explicitly set.
  public var hasTopicsPattern: Bool {return self._topicsPattern != nil}
  /// Clears the value of `topicsPattern`. Subsequent reads from it will return its default value.
  public mutating func clearTopicsPattern() {self._topicsPattern = nil}

  /// Only present when the client reconnects:
  public var topicsHash: String {
    get {return _topicsHash ?? String()}
    set {_topicsHash = newValue}
  }
  /// Returns true if `topicsHash` has been explicitly set.
  public var hasTopicsHash: Bool {return self._topicsHash != nil}
  /// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
  public mutating func clearTopicsHash() {self._topicsHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _watcherID: UInt64? = nil
  fileprivate var _namespace: String? = nil
  fileprivate var _topicsPattern: String? = nil
  fileprivate var _topicsHash: String? = nil
}

public struct Pulsar_Proto_CommandWatchTopicListSuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var watcherID: UInt64 {
    get {return _watcherID ?? 0}
    set {_watcherID = newValue}
  }
  /// Returns true if `watcherID` has been explicitly set.
  public var hasWatcherID: Bool {return self._watcherID != nil}
  /// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
  public mutating func clearWatcherID() {self._watcherID = nil}

  public var topic: [String] = []

  public var topicsHash: String {
    get {return _topicsHash ?? String()}
    set {_topicsHash = newValue}
  }
  /// Returns true if `topicsHash` has been explicitly set.
  public var hasTopicsHash: Bool {return self._topicsHash != nil}
  /// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
  public mutating func clearTopicsHash() {self._topicsHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _watcherID: UInt64? = nil
  fileprivate var _topicsHash: String? = nil
}

public struct Pulsar_Proto_CommandWatchTopicUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var watcherID: UInt64 {
    get {return _watcherID ?? 0}
    set {_watcherID = newValue}
  }
  /// Returns true if `watcherID` has been explicitly set.
  public var hasWatcherID: Bool {return self._watcherID != nil}
  /// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
  public mutating func clearWatcherID() {self._watcherID = nil}

  public var newTopics: [String] = []

  public var deletedTopics: [String] = []

  public var topicsHash: String {
    get {return _topicsHash ?? String()}
    set {_topicsHash = newValue}
  }
  /// Returns true if `topicsHash` has been explicitly set.
  public var hasTopicsHash: Bool {return self._topicsHash != nil}
  /// Clears the value of `topicsHash`. Subsequent reads from it will return its default value.
  public mutating func clearTopicsHash() {self._topicsHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _watcherID: UInt64? = nil
  fileprivate var _topicsHash: String? = nil
}

public struct Pulsar_Proto_CommandWatchTopicListClose: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var watcherID: UInt64 {
    get {return _watcherID ?? 0}
    set {_watcherID = newValue}
  }
  /// Returns true if `watcherID` has been explicitly set.
  public var hasWatcherID: Bool {return self._watcherID != nil}
  /// Clears the value of `watcherID`. Subsequent reads from it will return its default value.
  public mutating func clearWatcherID() {self._watcherID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _watcherID: UInt64? = nil
}

public struct Pulsar_Proto_CommandGetSchema: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var schemaVersion: Data {
    get {return _schemaVersion ?? Data()}
    set {_schemaVersion = newValue}
  }
  /// Returns true if `schemaVersion` has been explicitly set.
  public var hasSchemaVersion: Bool {return self._schemaVersion != nil}
  /// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSchemaVersion() {self._schemaVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _topic: String? = nil
  fileprivate var _schemaVersion: Data? = nil
}

public struct Pulsar_Proto_CommandGetSchemaResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var errorCode: Pulsar_Proto_ServerError {
    get {return _errorCode ?? .unknownError}
    set {_errorCode = newValue}
  }
  /// Returns true if `errorCode` has been explicitly set.
  public var hasErrorCode: Bool {return self._errorCode != nil}
  /// Clears the value of `errorCode`. Subsequent reads from it will return its default value.
  public mutating func clearErrorCode() {self._errorCode = nil}

  public var errorMessage: String {
    get {return _errorMessage ?? String()}
    set {_errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  public var hasErrorMessage: Bool {return self._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  public mutating func clearErrorMessage() {self._errorMessage = nil}

  public var schema: Pulsar_Proto_Schema {
    get {return _schema ?? Pulsar_Proto_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var schemaVersion: Data {
    get {return _schemaVersion ?? Data()}
    set {_schemaVersion = newValue}
  }
  /// Returns true if `schemaVersion` has been explicitly set.
  public var hasSchemaVersion: Bool {return self._schemaVersion != nil}
  /// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSchemaVersion() {self._schemaVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _errorCode: Pulsar_Proto_ServerError? = nil
  fileprivate var _errorMessage: String? = nil
  fileprivate var _schema: Pulsar_Proto_Schema? = nil
  fileprivate var _schemaVersion: Data? = nil
}

public struct Pulsar_Proto_CommandGetOrCreateSchema: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var schema: Pulsar_Proto_Schema {
    get {return _schema ?? Pulsar_Proto_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _topic: String? = nil
  fileprivate var _schema: Pulsar_Proto_Schema? = nil
}

public struct Pulsar_Proto_CommandGetOrCreateSchemaResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var errorCode: Pulsar_Proto_ServerError {
    get {return _errorCode ?? .unknownError}
    set {_errorCode = newValue}
  }
  /// Returns true if `errorCode` has been explicitly set.
  public var hasErrorCode: Bool {return self._errorCode != nil}
  /// Clears the value of `errorCode`. Subsequent reads from it will return its default value.
  public mutating func clearErrorCode() {self._errorCode = nil}

  public var errorMessage: String {
    get {return _errorMessage ?? String()}
    set {_errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  public var hasErrorMessage: Bool {return self._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  public mutating func clearErrorMessage() {self._errorMessage = nil}

  public var schemaVersion: Data {
    get {return _schemaVersion ?? Data()}
    set {_schemaVersion = newValue}
  }
  /// Returns true if `schemaVersion` has been explicitly set.
  public var hasSchemaVersion: Bool {return self._schemaVersion != nil}
  /// Clears the value of `schemaVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSchemaVersion() {self._schemaVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _errorCode: Pulsar_Proto_ServerError? = nil
  fileprivate var _errorMessage: String? = nil
  fileprivate var _schemaVersion: Data? = nil
}

public struct Pulsar_Proto_CommandTcClientConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var tcID: UInt64 {
    get {return _tcID ?? 0}
    set {_tcID = newValue}
  }
  /// Returns true if `tcID` has been explicitly set.
  public var hasTcID: Bool {return self._tcID != nil}
  /// Clears the value of `tcID`. Subsequent reads from it will return its default value.
  public mutating func clearTcID() {self._tcID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _tcID: UInt64? = nil
}

public struct Pulsar_Proto_CommandTcClientConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_CommandNewTxn: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnTtlSeconds: UInt64 {
    get {return _txnTtlSeconds ?? 0}
    set {_txnTtlSeconds = newValue}
  }
  /// Returns true if `txnTtlSeconds` has been explicitly set.
  public var hasTxnTtlSeconds: Bool {return self._txnTtlSeconds != nil}
  /// Clears the value of `txnTtlSeconds`. Subsequent reads from it will return its default value.
  public mutating func clearTxnTtlSeconds() {self._txnTtlSeconds = nil}

  public var tcID: UInt64 {
    get {return _tcID ?? 0}
    set {_tcID = newValue}
  }
  /// Returns true if `tcID` has been explicitly set.
  public var hasTcID: Bool {return self._tcID != nil}
  /// Clears the value of `tcID`. Subsequent reads from it will return its default value.
  public mutating func clearTcID() {self._tcID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnTtlSeconds: UInt64? = nil
  fileprivate var _tcID: UInt64? = nil
}

public struct Pulsar_Proto_CommandNewTxnResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_CommandAddPartitionToTxn: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var partitions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
}

public struct Pulsar_Proto_CommandAddPartitionToTxnResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_Subscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var subscription: String {
    get {return _subscription ?? String()}
    set {_subscription = newValue}
  }
  /// Returns true if `subscription` has been explicitly set.
  public var hasSubscription: Bool {return self._subscription != nil}
  /// Clears the value of `subscription`. Subsequent reads from it will return its default value.
  public mutating func clearSubscription() {self._subscription = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topic: String? = nil
  fileprivate var _subscription: String? = nil
}

public struct Pulsar_Proto_CommandAddSubscriptionToTxn: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var subscription: [Pulsar_Proto_Subscription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
}

public struct Pulsar_Proto_CommandAddSubscriptionToTxnResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_CommandEndTxn: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var txnAction: Pulsar_Proto_TxnAction {
    get {return _txnAction ?? .commit}
    set {_txnAction = newValue}
  }
  /// Returns true if `txnAction` has been explicitly set.
  public var hasTxnAction: Bool {return self._txnAction != nil}
  /// Clears the value of `txnAction`. Subsequent reads from it will return its default value.
  public mutating func clearTxnAction() {self._txnAction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _txnAction: Pulsar_Proto_TxnAction? = nil
}

public struct Pulsar_Proto_CommandEndTxnResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_CommandEndTxnOnPartition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var txnAction: Pulsar_Proto_TxnAction {
    get {return _txnAction ?? .commit}
    set {_txnAction = newValue}
  }
  /// Returns true if `txnAction` has been explicitly set.
  public var hasTxnAction: Bool {return self._txnAction != nil}
  /// Clears the value of `txnAction`. Subsequent reads from it will return its default value.
  public mutating func clearTxnAction() {self._txnAction = nil}

  public var txnidLeastBitsOfLowWatermark: UInt64 {
    get {return _txnidLeastBitsOfLowWatermark ?? 0}
    set {_txnidLeastBitsOfLowWatermark = newValue}
  }
  /// Returns true if `txnidLeastBitsOfLowWatermark` has been explicitly set.
  public var hasTxnidLeastBitsOfLowWatermark: Bool {return self._txnidLeastBitsOfLowWatermark != nil}
  /// Clears the value of `txnidLeastBitsOfLowWatermark`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBitsOfLowWatermark() {self._txnidLeastBitsOfLowWatermark = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _topic: String? = nil
  fileprivate var _txnAction: Pulsar_Proto_TxnAction? = nil
  fileprivate var _txnidLeastBitsOfLowWatermark: UInt64? = nil
}

public struct Pulsar_Proto_CommandEndTxnOnPartitionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_CommandEndTxnOnSubscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var subscription: Pulsar_Proto_Subscription {
    get {return _subscription ?? Pulsar_Proto_Subscription()}
    set {_subscription = newValue}
  }
  /// Returns true if `subscription` has been explicitly set.
  public var hasSubscription: Bool {return self._subscription != nil}
  /// Clears the value of `subscription`. Subsequent reads from it will return its default value.
  public mutating func clearSubscription() {self._subscription = nil}

  public var txnAction: Pulsar_Proto_TxnAction {
    get {return _txnAction ?? .commit}
    set {_txnAction = newValue}
  }
  /// Returns true if `txnAction` has been explicitly set.
  public var hasTxnAction: Bool {return self._txnAction != nil}
  /// Clears the value of `txnAction`. Subsequent reads from it will return its default value.
  public mutating func clearTxnAction() {self._txnAction = nil}

  public var txnidLeastBitsOfLowWatermark: UInt64 {
    get {return _txnidLeastBitsOfLowWatermark ?? 0}
    set {_txnidLeastBitsOfLowWatermark = newValue}
  }
  /// Returns true if `txnidLeastBitsOfLowWatermark` has been explicitly set.
  public var hasTxnidLeastBitsOfLowWatermark: Bool {return self._txnidLeastBitsOfLowWatermark != nil}
  /// Clears the value of `txnidLeastBitsOfLowWatermark`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBitsOfLowWatermark() {self._txnidLeastBitsOfLowWatermark = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _subscription: Pulsar_Proto_Subscription? = nil
  fileprivate var _txnAction: Pulsar_Proto_TxnAction? = nil
  fileprivate var _txnidLeastBitsOfLowWatermark: UInt64? = nil
}

public struct Pulsar_Proto_CommandEndTxnOnSubscriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: UInt64 {
    get {return _requestID ?? 0}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var txnidLeastBits: UInt64 {
    get {return _txnidLeastBits ?? 0}
    set {_txnidLeastBits = newValue}
  }
  /// Returns true if `txnidLeastBits` has been explicitly set.
  public var hasTxnidLeastBits: Bool {return self._txnidLeastBits != nil}
  /// Clears the value of `txnidLeastBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidLeastBits() {self._txnidLeastBits = nil}

  public var txnidMostBits: UInt64 {
    get {return _txnidMostBits ?? 0}
    set {_txnidMostBits = newValue}
  }
  /// Returns true if `txnidMostBits` has been explicitly set.
  public var hasTxnidMostBits: Bool {return self._txnidMostBits != nil}
  /// Clears the value of `txnidMostBits`. Subsequent reads from it will return its default value.
  public mutating func clearTxnidMostBits() {self._txnidMostBits = nil}

  public var error: Pulsar_Proto_ServerError {
    get {return _error ?? .unknownError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: UInt64? = nil
  fileprivate var _txnidLeastBits: UInt64? = nil
  fileprivate var _txnidMostBits: UInt64? = nil
  fileprivate var _error: Pulsar_Proto_ServerError? = nil
  fileprivate var _message: String? = nil
}

public struct Pulsar_Proto_BaseCommand: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Pulsar_Proto_BaseCommand.TypeEnum {
    get {return _storage._type ?? .connect}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var connect: Pulsar_Proto_CommandConnect {
    get {return _storage._connect ?? Pulsar_Proto_CommandConnect()}
    set {_uniqueStorage()._connect = newValue}
  }
  /// Returns true if `connect` has been explicitly set.
  public var hasConnect: Bool {return _storage._connect != nil}
  /// Clears the value of `connect`. Subsequent reads from it will return its default value.
  public mutating func clearConnect() {_uniqueStorage()._connect = nil}

  public var connected: Pulsar_Proto_CommandConnected {
    get {return _storage._connected ?? Pulsar_Proto_CommandConnected()}
    set {_uniqueStorage()._connected = newValue}
  }
  /// Returns true if `connected` has been explicitly set.
  public var hasConnected: Bool {return _storage._connected != nil}
  /// Clears the value of `connected`. Subsequent reads from it will return its default value.
  public mutating func clearConnected() {_uniqueStorage()._connected = nil}

  public var subscribe: Pulsar_Proto_CommandSubscribe {
    get {return _storage._subscribe ?? Pulsar_Proto_CommandSubscribe()}
    set {_uniqueStorage()._subscribe = newValue}
  }
  /// Returns true if `subscribe` has been explicitly set.
  public var hasSubscribe: Bool {return _storage._subscribe != nil}
  /// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribe() {_uniqueStorage()._subscribe = nil}

  public var producer: Pulsar_Proto_CommandProducer {
    get {return _storage._producer ?? Pulsar_Proto_CommandProducer()}
    set {_uniqueStorage()._producer = newValue}
  }
  /// Returns true if `producer` has been explicitly set.
  public var hasProducer: Bool {return _storage._producer != nil}
  /// Clears the value of `producer`. Subsequent reads from it will return its default value.
  public mutating func clearProducer() {_uniqueStorage()._producer = nil}

  public var send: Pulsar_Proto_CommandSend {
    get {return _storage._send ?? Pulsar_Proto_CommandSend()}
    set {_uniqueStorage()._send = newValue}
  }
  /// Returns true if `send` has been explicitly set.
  public var hasSend: Bool {return _storage._send != nil}
  /// Clears the value of `send`. Subsequent reads from it will return its default value.
  public mutating func clearSend() {_uniqueStorage()._send = nil}

  public var sendReceipt: Pulsar_Proto_CommandSendReceipt {
    get {return _storage._sendReceipt ?? Pulsar_Proto_CommandSendReceipt()}
    set {_uniqueStorage()._sendReceipt = newValue}
  }
  /// Returns true if `sendReceipt` has been explicitly set.
  public var hasSendReceipt: Bool {return _storage._sendReceipt != nil}
  /// Clears the value of `sendReceipt`. Subsequent reads from it will return its default value.
  public mutating func clearSendReceipt() {_uniqueStorage()._sendReceipt = nil}

  public var sendError: Pulsar_Proto_CommandSendError {
    get {return _storage._sendError ?? Pulsar_Proto_CommandSendError()}
    set {_uniqueStorage()._sendError = newValue}
  }
  /// Returns true if `sendError` has been explicitly set.
  public var hasSendError: Bool {return _storage._sendError != nil}
  /// Clears the value of `sendError`. Subsequent reads from it will return its default value.
  public mutating func clearSendError() {_uniqueStorage()._sendError = nil}

  public var message: Pulsar_Proto_CommandMessage {
    get {return _storage._message ?? Pulsar_Proto_CommandMessage()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {_uniqueStorage()._message = nil}

  public var ack: Pulsar_Proto_CommandAck {
    get {return _storage._ack ?? Pulsar_Proto_CommandAck()}
    set {_uniqueStorage()._ack = newValue}
  }
  /// Returns true if `ack` has been explicitly set.
  public var hasAck: Bool {return _storage._ack != nil}
  /// Clears the value of `ack`. Subsequent reads from it will return its default value.
  public mutating func clearAck() {_uniqueStorage()._ack = nil}

  public var flow: Pulsar_Proto_CommandFlow {
    get {return _storage._flow ?? Pulsar_Proto_CommandFlow()}
    set {_uniqueStorage()._flow = newValue}
  }
  /// Returns true if `flow` has been explicitly set.
  public var hasFlow: Bool {return _storage._flow != nil}
  /// Clears the value of `flow`. Subsequent reads from it will return its default value.
  public mutating func clearFlow() {_uniqueStorage()._flow = nil}

  public var unsubscribe: Pulsar_Proto_CommandUnsubscribe {
    get {return _storage._unsubscribe ?? Pulsar_Proto_CommandUnsubscribe()}
    set {_uniqueStorage()._unsubscribe = newValue}
  }
  /// Returns true if `unsubscribe` has been explicitly set.
  public var hasUnsubscribe: Bool {return _storage._unsubscribe != nil}
  /// Clears the value of `unsubscribe`. Subsequent reads from it will return its default value.
  public mutating func clearUnsubscribe() {_uniqueStorage()._unsubscribe = nil}

  public var success: Pulsar_Proto_CommandSuccess {
    get {return _storage._success ?? Pulsar_Proto_CommandSuccess()}
    set {_uniqueStorage()._success = newValue}
  }
  /// Returns true if `success` has been explicitly set.
  public var hasSuccess: Bool {return _storage._success != nil}
  /// Clears the value of `success`. Subsequent reads from it will return its default value.
  public mutating func clearSuccess() {_uniqueStorage()._success = nil}

  public var error: Pulsar_Proto_CommandError {
    get {return _storage._error ?? Pulsar_Proto_CommandError()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {_uniqueStorage()._error = nil}

  public var closeProducer: Pulsar_Proto_CommandCloseProducer {
    get {return _storage._closeProducer ?? Pulsar_Proto_CommandCloseProducer()}
    set {_uniqueStorage()._closeProducer = newValue}
  }
  /// Returns true if `closeProducer` has been explicitly set.
  public var hasCloseProducer: Bool {return _storage._closeProducer != nil}
  /// Clears the value of `closeProducer`. Subsequent reads from it will return its default value.
  public mutating func clearCloseProducer() {_uniqueStorage()._closeProducer = nil}

  public var closeConsumer: Pulsar_Proto_CommandCloseConsumer {
    get {return _storage._closeConsumer ?? Pulsar_Proto_CommandCloseConsumer()}
    set {_uniqueStorage()._closeConsumer = newValue}
  }
  /// Returns true if `closeConsumer` has been explicitly set.
  public var hasCloseConsumer: Bool {return _storage._closeConsumer != nil}
  /// Clears the value of `closeConsumer`. Subsequent reads from it will return its default value.
  public mutating func clearCloseConsumer() {_uniqueStorage()._closeConsumer = nil}

  public var producerSuccess: Pulsar_Proto_CommandProducerSuccess {
    get {return _storage._producerSuccess ?? Pulsar_Proto_CommandProducerSuccess()}
    set {_uniqueStorage()._producerSuccess = newValue}
  }
  /// Returns true if `producerSuccess` has been explicitly set.
  public var hasProducerSuccess: Bool {return _storage._producerSuccess != nil}
  /// Clears the value of `producerSuccess`. Subsequent reads from it will return its default value.
  public mutating func clearProducerSuccess() {_uniqueStorage()._producerSuccess = nil}

  public var ping: Pulsar_Proto_CommandPing {
    get {return _storage._ping ?? Pulsar_Proto_CommandPing()}
    set {_uniqueStorage()._ping = newValue}
  }
  /// Returns true if `ping` has been explicitly set.
  public var hasPing: Bool {return _storage._ping != nil}
  /// Clears the value of `ping`. Subsequent reads from it will return its default value.
  public mutating func clearPing() {_uniqueStorage()._ping = nil}

  public var pong: Pulsar_Proto_CommandPong {
    get {return _storage._pong ?? Pulsar_Proto_CommandPong()}
    set {_uniqueStorage()._pong = newValue}
  }
  /// Returns true if `pong` has been explicitly set.
  public var hasPong: Bool {return _storage._pong != nil}
  /// Clears the value of `pong`. Subsequent reads from it will return its default value.
  public mutating func clearPong() {_uniqueStorage()._pong = nil}

  public var redeliverUnacknowledgedMessages: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages {
    get {return _storage._redeliverUnacknowledgedMessages ?? Pulsar_Proto_CommandRedeliverUnacknowledgedMessages()}
    set {_uniqueStorage()._redeliverUnacknowledgedMessages = newValue}
  }
  /// Returns true if `redeliverUnacknowledgedMessages` has been explicitly set.
  public var hasRedeliverUnacknowledgedMessages: Bool {return _storage._redeliverUnacknowledgedMessages != nil}
  /// Clears the value of `redeliverUnacknowledgedMessages`. Subsequent reads from it will return its default value.
  public mutating func clearRedeliverUnacknowledgedMessages() {_uniqueStorage()._redeliverUnacknowledgedMessages = nil}

  public var partitionMetadata: Pulsar_Proto_CommandPartitionedTopicMetadata {
    get {return _storage._partitionMetadata ?? Pulsar_Proto_CommandPartitionedTopicMetadata()}
    set {_uniqueStorage()._partitionMetadata = newValue}
  }
  /// Returns true if `partitionMetadata` has been explicitly set.
  public var hasPartitionMetadata: Bool {return _storage._partitionMetadata != nil}
  /// Clears the value of `partitionMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionMetadata() {_uniqueStorage()._partitionMetadata = nil}

  public var partitionMetadataResponse: Pulsar_Proto_CommandPartitionedTopicMetadataResponse {
    get {return _storage._partitionMetadataResponse ?? Pulsar_Proto_CommandPartitionedTopicMetadataResponse()}
    set {_uniqueStorage()._partitionMetadataResponse = newValue}
  }
  /// Returns true if `partitionMetadataResponse` has been explicitly set.
  public var hasPartitionMetadataResponse: Bool {return _storage._partitionMetadataResponse != nil}
  /// Clears the value of `partitionMetadataResponse`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionMetadataResponse() {_uniqueStorage()._partitionMetadataResponse = nil}

  public var lookupTopic: Pulsar_Proto_CommandLookupTopic {
    get {return _storage._lookupTopic ?? Pulsar_Proto_CommandLookupTopic()}
    set {_uniqueStorage()._lookupTopic = newValue}
  }
  /// Returns true if `lookupTopic` has been explicitly set.
  public var hasLookupTopic: Bool {return _storage._lookupTopic != nil}
  /// Clears the value of `lookupTopic`. Subsequent reads from it will return its default value.
  public mutating func clearLookupTopic() {_uniqueStorage()._lookupTopic = nil}

  public var lookupTopicResponse: Pulsar_Proto_CommandLookupTopicResponse {
    get {return _storage._lookupTopicResponse ?? Pulsar_Proto_CommandLookupTopicResponse()}
    set {_uniqueStorage()._lookupTopicResponse = newValue}
  }
  /// Returns true if `lookupTopicResponse` has been explicitly set.
  public var hasLookupTopicResponse: Bool {return _storage._lookupTopicResponse != nil}
  /// Clears the value of `lookupTopicResponse`. Subsequent reads from it will return its default value.
  public mutating func clearLookupTopicResponse() {_uniqueStorage()._lookupTopicResponse = nil}

  public var consumerStats: Pulsar_Proto_CommandConsumerStats {
    get {return _storage._consumerStats ?? Pulsar_Proto_CommandConsumerStats()}
    set {_uniqueStorage()._consumerStats = newValue}
  }
  /// Returns true if `consumerStats` has been explicitly set.
  public var hasConsumerStats: Bool {return _storage._consumerStats != nil}
  /// Clears the value of `consumerStats`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerStats() {_uniqueStorage()._consumerStats = nil}

  public var consumerStatsResponse: Pulsar_Proto_CommandConsumerStatsResponse {
    get {return _storage._consumerStatsResponse ?? Pulsar_Proto_CommandConsumerStatsResponse()}
    set {_uniqueStorage()._consumerStatsResponse = newValue}
  }
  /// Returns true if `consumerStatsResponse` has been explicitly set.
  public var hasConsumerStatsResponse: Bool {return _storage._consumerStatsResponse != nil}
  /// Clears the value of `consumerStatsResponse`. Subsequent reads from it will return its default value.
  public mutating func clearConsumerStatsResponse() {_uniqueStorage()._consumerStatsResponse = nil}

  public var reachedEndOfTopic: Pulsar_Proto_CommandReachedEndOfTopic {
    get {return _storage._reachedEndOfTopic ?? Pulsar_Proto_CommandReachedEndOfTopic()}
    set {_uniqueStorage()._reachedEndOfTopic = newValue}
  }
  /// Returns true if `reachedEndOfTopic` has been explicitly set.
  public var hasReachedEndOfTopic: Bool {return _storage._reachedEndOfTopic != nil}
  /// Clears the value of `reachedEndOfTopic`. Subsequent reads from it will return its default value.
  public mutating func clearReachedEndOfTopic() {_uniqueStorage()._reachedEndOfTopic = nil}

  public var seek: Pulsar_Proto_CommandSeek {
    get {return _storage._seek ?? Pulsar_Proto_CommandSeek()}
    set {_uniqueStorage()._seek = newValue}
  }
  /// Returns true if `seek` has been explicitly set.
  public var hasSeek: Bool {return _storage._seek != nil}
  /// Clears the value of `seek`. Subsequent reads from it will return its default value.
  public mutating func clearSeek() {_uniqueStorage()._seek = nil}

  public var getLastMessageID: Pulsar_Proto_CommandGetLastMessageId {
    get {return _storage._getLastMessageID ?? Pulsar_Proto_CommandGetLastMessageId()}
    set {_uniqueStorage()._getLastMessageID = newValue}
  }
  /// Returns true if `getLastMessageID` has been explicitly set.
  public var hasGetLastMessageID: Bool {return _storage._getLastMessageID != nil}
  /// Clears the value of `getLastMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearGetLastMessageID() {_uniqueStorage()._getLastMessageID = nil}

  public var getLastMessageIDResponse: Pulsar_Proto_CommandGetLastMessageIdResponse {
    get {return _storage._getLastMessageIDResponse ?? Pulsar_Proto_CommandGetLastMessageIdResponse()}
    set {_uniqueStorage()._getLastMessageIDResponse = newValue}
  }
  /// Returns true if `getLastMessageIDResponse` has been explicitly set.
  public var hasGetLastMessageIDResponse: Bool {return _storage._getLastMessageIDResponse != nil}
  /// Clears the value of `getLastMessageIDResponse`. Subsequent reads from it will return its default value.
  public mutating func clearGetLastMessageIDResponse() {_uniqueStorage()._getLastMessageIDResponse = nil}

  public var activeConsumerChange: Pulsar_Proto_CommandActiveConsumerChange {
    get {return _storage._activeConsumerChange ?? Pulsar_Proto_CommandActiveConsumerChange()}
    set {_uniqueStorage()._activeConsumerChange = newValue}
  }
  /// Returns true if `activeConsumerChange` has been explicitly set.
  public var hasActiveConsumerChange: Bool {return _storage._activeConsumerChange != nil}
  /// Clears the value of `activeConsumerChange`. Subsequent reads from it will return its default value.
  public mutating func clearActiveConsumerChange() {_uniqueStorage()._activeConsumerChange = nil}

  public var getTopicsOfNamespace: Pulsar_Proto_CommandGetTopicsOfNamespace {
    get {return _storage._getTopicsOfNamespace ?? Pulsar_Proto_CommandGetTopicsOfNamespace()}
    set {_uniqueStorage()._getTopicsOfNamespace = newValue}
  }
  /// Returns true if `getTopicsOfNamespace` has been explicitly set.
  public var hasGetTopicsOfNamespace: Bool {return _storage._getTopicsOfNamespace != nil}
  /// Clears the value of `getTopicsOfNamespace`. Subsequent reads from it will return its default value.
  public mutating func clearGetTopicsOfNamespace() {_uniqueStorage()._getTopicsOfNamespace = nil}

  public var getTopicsOfNamespaceResponse: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse {
    get {return _storage._getTopicsOfNamespaceResponse ?? Pulsar_Proto_CommandGetTopicsOfNamespaceResponse()}
    set {_uniqueStorage()._getTopicsOfNamespaceResponse = newValue}
  }
  /// Returns true if `getTopicsOfNamespaceResponse` has been explicitly set.
  public var hasGetTopicsOfNamespaceResponse: Bool {return _storage._getTopicsOfNamespaceResponse != nil}
  /// Clears the value of `getTopicsOfNamespaceResponse`. Subsequent reads from it will return its default value.
  public mutating func clearGetTopicsOfNamespaceResponse() {_uniqueStorage()._getTopicsOfNamespaceResponse = nil}

  public var getSchema: Pulsar_Proto_CommandGetSchema {
    get {return _storage._getSchema ?? Pulsar_Proto_CommandGetSchema()}
    set {_uniqueStorage()._getSchema = newValue}
  }
  /// Returns true if `getSchema` has been explicitly set.
  public var hasGetSchema: Bool {return _storage._getSchema != nil}
  /// Clears the value of `getSchema`. Subsequent reads from it will return its default value.
  public mutating func clearGetSchema() {_uniqueStorage()._getSchema = nil}

  public var getSchemaResponse: Pulsar_Proto_CommandGetSchemaResponse {
    get {return _storage._getSchemaResponse ?? Pulsar_Proto_CommandGetSchemaResponse()}
    set {_uniqueStorage()._getSchemaResponse = newValue}
  }
  /// Returns true if `getSchemaResponse` has been explicitly set.
  public var hasGetSchemaResponse: Bool {return _storage._getSchemaResponse != nil}
  /// Clears the value of `getSchemaResponse`. Subsequent reads from it will return its default value.
  public mutating func clearGetSchemaResponse() {_uniqueStorage()._getSchemaResponse = nil}

  public var authChallenge: Pulsar_Proto_CommandAuthChallenge {
    get {return _storage._authChallenge ?? Pulsar_Proto_CommandAuthChallenge()}
    set {_uniqueStorage()._authChallenge = newValue}
  }
  /// Returns true if `authChallenge` has been explicitly set.
  public var hasAuthChallenge: Bool {return _storage._authChallenge != nil}
  /// Clears the value of `authChallenge`. Subsequent reads from it will return its default value.
  public mutating func clearAuthChallenge() {_uniqueStorage()._authChallenge = nil}

  public var authResponse: Pulsar_Proto_CommandAuthResponse {
    get {return _storage._authResponse ?? Pulsar_Proto_CommandAuthResponse()}
    set {_uniqueStorage()._authResponse = newValue}
  }
  /// Returns true if `authResponse` has been explicitly set.
  public var hasAuthResponse: Bool {return _storage._authResponse != nil}
  /// Clears the value of `authResponse`. Subsequent reads from it will return its default value.
  public mutating func clearAuthResponse() {_uniqueStorage()._authResponse = nil}

  public var ackResponse: Pulsar_Proto_CommandAckResponse {
    get {return _storage._ackResponse ?? Pulsar_Proto_CommandAckResponse()}
    set {_uniqueStorage()._ackResponse = newValue}
  }
  /// Returns true if `ackResponse` has been explicitly set.
  public var hasAckResponse: Bool {return _storage._ackResponse != nil}
  /// Clears the value of `ackResponse`. Subsequent reads from it will return its default value.
  public mutating func clearAckResponse() {_uniqueStorage()._ackResponse = nil}

  public var getOrCreateSchema: Pulsar_Proto_CommandGetOrCreateSchema {
    get {return _storage._getOrCreateSchema ?? Pulsar_Proto_CommandGetOrCreateSchema()}
    set {_uniqueStorage()._getOrCreateSchema = newValue}
  }
  /// Returns true if `getOrCreateSchema` has been explicitly set.
  public var hasGetOrCreateSchema: Bool {return _storage._getOrCreateSchema != nil}
  /// Clears the value of `getOrCreateSchema`. Subsequent reads from it will return its default value.
  public mutating func clearGetOrCreateSchema() {_uniqueStorage()._getOrCreateSchema = nil}

  public var getOrCreateSchemaResponse: Pulsar_Proto_CommandGetOrCreateSchemaResponse {
    get {return _storage._getOrCreateSchemaResponse ?? Pulsar_Proto_CommandGetOrCreateSchemaResponse()}
    set {_uniqueStorage()._getOrCreateSchemaResponse = newValue}
  }
  /// Returns true if `getOrCreateSchemaResponse` has been explicitly set.
  public var hasGetOrCreateSchemaResponse: Bool {return _storage._getOrCreateSchemaResponse != nil}
  /// Clears the value of `getOrCreateSchemaResponse`. Subsequent reads from it will return its default value.
  public mutating func clearGetOrCreateSchemaResponse() {_uniqueStorage()._getOrCreateSchemaResponse = nil}

  /// transaction related
  public var newTxn: Pulsar_Proto_CommandNewTxn {
    get {return _storage._newTxn ?? Pulsar_Proto_CommandNewTxn()}
    set {_uniqueStorage()._newTxn = newValue}
  }
  /// Returns true if `newTxn` has been explicitly set.
  public var hasNewTxn: Bool {return _storage._newTxn != nil}
  /// Clears the value of `newTxn`. Subsequent reads from it will return its default value.
  public mutating func clearNewTxn() {_uniqueStorage()._newTxn = nil}

  public var newTxnResponse: Pulsar_Proto_CommandNewTxnResponse {
    get {return _storage._newTxnResponse ?? Pulsar_Proto_CommandNewTxnResponse()}
    set {_uniqueStorage()._newTxnResponse = newValue}
  }
  /// Returns true if `newTxnResponse` has been explicitly set.
  public var hasNewTxnResponse: Bool {return _storage._newTxnResponse != nil}
  /// Clears the value of `newTxnResponse`. Subsequent reads from it will return its default value.
  public mutating func clearNewTxnResponse() {_uniqueStorage()._newTxnResponse = nil}

  public var addPartitionToTxn: Pulsar_Proto_CommandAddPartitionToTxn {
    get {return _storage._addPartitionToTxn ?? Pulsar_Proto_CommandAddPartitionToTxn()}
    set {_uniqueStorage()._addPartitionToTxn = newValue}
  }
  /// Returns true if `addPartitionToTxn` has been explicitly set.
  public var hasAddPartitionToTxn: Bool {return _storage._addPartitionToTxn != nil}
  /// Clears the value of `addPartitionToTxn`. Subsequent reads from it will return its default value.
  public mutating func clearAddPartitionToTxn() {_uniqueStorage()._addPartitionToTxn = nil}

  public var addPartitionToTxnResponse: Pulsar_Proto_CommandAddPartitionToTxnResponse {
    get {return _storage._addPartitionToTxnResponse ?? Pulsar_Proto_CommandAddPartitionToTxnResponse()}
    set {_uniqueStorage()._addPartitionToTxnResponse = newValue}
  }
  /// Returns true if `addPartitionToTxnResponse` has been explicitly set.
  public var hasAddPartitionToTxnResponse: Bool {return _storage._addPartitionToTxnResponse != nil}
  /// Clears the value of `addPartitionToTxnResponse`. Subsequent reads from it will return its default value.
  public mutating func clearAddPartitionToTxnResponse() {_uniqueStorage()._addPartitionToTxnResponse = nil}

  public var addSubscriptionToTxn: Pulsar_Proto_CommandAddSubscriptionToTxn {
    get {return _storage._addSubscriptionToTxn ?? Pulsar_Proto_CommandAddSubscriptionToTxn()}
    set {_uniqueStorage()._addSubscriptionToTxn = newValue}
  }
  /// Returns true if `addSubscriptionToTxn` has been explicitly set.
  public var hasAddSubscriptionToTxn: Bool {return _storage._addSubscriptionToTxn != nil}
  /// Clears the value of `addSubscriptionToTxn`. Subsequent reads from it will return its default value.
  public mutating func clearAddSubscriptionToTxn() {_uniqueStorage()._addSubscriptionToTxn = nil}

  public var addSubscriptionToTxnResponse: Pulsar_Proto_CommandAddSubscriptionToTxnResponse {
    get {return _storage._addSubscriptionToTxnResponse ?? Pulsar_Proto_CommandAddSubscriptionToTxnResponse()}
    set {_uniqueStorage()._addSubscriptionToTxnResponse = newValue}
  }
  /// Returns true if `addSubscriptionToTxnResponse` has been explicitly set.
  public var hasAddSubscriptionToTxnResponse: Bool {return _storage._addSubscriptionToTxnResponse != nil}
  /// Clears the value of `addSubscriptionToTxnResponse`. Subsequent reads from it will return its default value.
  public mutating func clearAddSubscriptionToTxnResponse() {_uniqueStorage()._addSubscriptionToTxnResponse = nil}

  public var endTxn: Pulsar_Proto_CommandEndTxn {
    get {return _storage._endTxn ?? Pulsar_Proto_CommandEndTxn()}
    set {_uniqueStorage()._endTxn = newValue}
  }
  /// Returns true if `endTxn` has been explicitly set.
  public var hasEndTxn: Bool {return _storage._endTxn != nil}
  /// Clears the value of `endTxn`. Subsequent reads from it will return its default value.
  public mutating func clearEndTxn() {_uniqueStorage()._endTxn = nil}

  public var endTxnResponse: Pulsar_Proto_CommandEndTxnResponse {
    get {return _storage._endTxnResponse ?? Pulsar_Proto_CommandEndTxnResponse()}
    set {_uniqueStorage()._endTxnResponse = newValue}
  }
  /// Returns true if `endTxnResponse` has been explicitly set.
  public var hasEndTxnResponse: Bool {return _storage._endTxnResponse != nil}
  /// Clears the value of `endTxnResponse`. Subsequent reads from it will return its default value.
  public mutating func clearEndTxnResponse() {_uniqueStorage()._endTxnResponse = nil}

  public var endTxnOnPartition: Pulsar_Proto_CommandEndTxnOnPartition {
    get {return _storage._endTxnOnPartition ?? Pulsar_Proto_CommandEndTxnOnPartition()}
    set {_uniqueStorage()._endTxnOnPartition = newValue}
  }
  /// Returns true if `endTxnOnPartition` has been explicitly set.
  public var hasEndTxnOnPartition: Bool {return _storage._endTxnOnPartition != nil}
  /// Clears the value of `endTxnOnPartition`. Subsequent reads from it will return its default value.
  public mutating func clearEndTxnOnPartition() {_uniqueStorage()._endTxnOnPartition = nil}

  public var endTxnOnPartitionResponse: Pulsar_Proto_CommandEndTxnOnPartitionResponse {
    get {return _storage._endTxnOnPartitionResponse ?? Pulsar_Proto_CommandEndTxnOnPartitionResponse()}
    set {_uniqueStorage()._endTxnOnPartitionResponse = newValue}
  }
  /// Returns true if `endTxnOnPartitionResponse` has been explicitly set.
  public var hasEndTxnOnPartitionResponse: Bool {return _storage._endTxnOnPartitionResponse != nil}
  /// Clears the value of `endTxnOnPartitionResponse`. Subsequent reads from it will return its default value.
  public mutating func clearEndTxnOnPartitionResponse() {_uniqueStorage()._endTxnOnPartitionResponse = nil}

  public var endTxnOnSubscription: Pulsar_Proto_CommandEndTxnOnSubscription {
    get {return _storage._endTxnOnSubscription ?? Pulsar_Proto_CommandEndTxnOnSubscription()}
    set {_uniqueStorage()._endTxnOnSubscription = newValue}
  }
  /// Returns true if `endTxnOnSubscription` has been explicitly set.
  public var hasEndTxnOnSubscription: Bool {return _storage._endTxnOnSubscription != nil}
  /// Clears the value of `endTxnOnSubscription`. Subsequent reads from it will return its default value.
  public mutating func clearEndTxnOnSubscription() {_uniqueStorage()._endTxnOnSubscription = nil}

  public var endTxnOnSubscriptionResponse: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse {
    get {return _storage._endTxnOnSubscriptionResponse ?? Pulsar_Proto_CommandEndTxnOnSubscriptionResponse()}
    set {_uniqueStorage()._endTxnOnSubscriptionResponse = newValue}
  }
  /// Returns true if `endTxnOnSubscriptionResponse` has been explicitly set.
  public var hasEndTxnOnSubscriptionResponse: Bool {return _storage._endTxnOnSubscriptionResponse != nil}
  /// Clears the value of `endTxnOnSubscriptionResponse`. Subsequent reads from it will return its default value.
  public mutating func clearEndTxnOnSubscriptionResponse() {_uniqueStorage()._endTxnOnSubscriptionResponse = nil}

  public var tcClientConnectRequest: Pulsar_Proto_CommandTcClientConnectRequest {
    get {return _storage._tcClientConnectRequest ?? Pulsar_Proto_CommandTcClientConnectRequest()}
    set {_uniqueStorage()._tcClientConnectRequest = newValue}
  }
  /// Returns true if `tcClientConnectRequest` has been explicitly set.
  public var hasTcClientConnectRequest: Bool {return _storage._tcClientConnectRequest != nil}
  /// Clears the value of `tcClientConnectRequest`. Subsequent reads from it will return its default value.
  public mutating func clearTcClientConnectRequest() {_uniqueStorage()._tcClientConnectRequest = nil}

  public var tcClientConnectResponse: Pulsar_Proto_CommandTcClientConnectResponse {
    get {return _storage._tcClientConnectResponse ?? Pulsar_Proto_CommandTcClientConnectResponse()}
    set {_uniqueStorage()._tcClientConnectResponse = newValue}
  }
  /// Returns true if `tcClientConnectResponse` has been explicitly set.
  public var hasTcClientConnectResponse: Bool {return _storage._tcClientConnectResponse != nil}
  /// Clears the value of `tcClientConnectResponse`. Subsequent reads from it will return its default value.
  public mutating func clearTcClientConnectResponse() {_uniqueStorage()._tcClientConnectResponse = nil}

  public var watchTopicList: Pulsar_Proto_CommandWatchTopicList {
    get {return _storage._watchTopicList ?? Pulsar_Proto_CommandWatchTopicList()}
    set {_uniqueStorage()._watchTopicList = newValue}
  }
  /// Returns true if `watchTopicList` has been explicitly set.
  public var hasWatchTopicList: Bool {return _storage._watchTopicList != nil}
  /// Clears the value of `watchTopicList`. Subsequent reads from it will return its default value.
  public mutating func clearWatchTopicList() {_uniqueStorage()._watchTopicList = nil}

  public var watchTopicListSuccess: Pulsar_Proto_CommandWatchTopicListSuccess {
    get {return _storage._watchTopicListSuccess ?? Pulsar_Proto_CommandWatchTopicListSuccess()}
    set {_uniqueStorage()._watchTopicListSuccess = newValue}
  }
  /// Returns true if `watchTopicListSuccess` has been explicitly set.
  public var hasWatchTopicListSuccess: Bool {return _storage._watchTopicListSuccess != nil}
  /// Clears the value of `watchTopicListSuccess`. Subsequent reads from it will return its default value.
  public mutating func clearWatchTopicListSuccess() {_uniqueStorage()._watchTopicListSuccess = nil}

  public var watchTopicUpdate: Pulsar_Proto_CommandWatchTopicUpdate {
    get {return _storage._watchTopicUpdate ?? Pulsar_Proto_CommandWatchTopicUpdate()}
    set {_uniqueStorage()._watchTopicUpdate = newValue}
  }
  /// Returns true if `watchTopicUpdate` has been explicitly set.
  public var hasWatchTopicUpdate: Bool {return _storage._watchTopicUpdate != nil}
  /// Clears the value of `watchTopicUpdate`. Subsequent reads from it will return its default value.
  public mutating func clearWatchTopicUpdate() {_uniqueStorage()._watchTopicUpdate = nil}

  public var watchTopicListClose: Pulsar_Proto_CommandWatchTopicListClose {
    get {return _storage._watchTopicListClose ?? Pulsar_Proto_CommandWatchTopicListClose()}
    set {_uniqueStorage()._watchTopicListClose = newValue}
  }
  /// Returns true if `watchTopicListClose` has been explicitly set.
  public var hasWatchTopicListClose: Bool {return _storage._watchTopicListClose != nil}
  /// Clears the value of `watchTopicListClose`. Subsequent reads from it will return its default value.
  public mutating func clearWatchTopicListClose() {_uniqueStorage()._watchTopicListClose = nil}

  public var topicMigrated: Pulsar_Proto_CommandTopicMigrated {
    get {return _storage._topicMigrated ?? Pulsar_Proto_CommandTopicMigrated()}
    set {_uniqueStorage()._topicMigrated = newValue}
  }
  /// Returns true if `topicMigrated` has been explicitly set.
  public var hasTopicMigrated: Bool {return _storage._topicMigrated != nil}
  /// Clears the value of `topicMigrated`. Subsequent reads from it will return its default value.
  public mutating func clearTopicMigrated() {_uniqueStorage()._topicMigrated = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case connect = 2
    case connected = 3
    case subscribe = 4
    case producer = 5
    case send = 6
    case sendReceipt = 7
    case sendError = 8
    case message = 9
    case ack = 10
    case flow = 11
    case unsubscribe = 12
    case success = 13
    case error = 14
    case closeProducer = 15
    case closeConsumer = 16
    case producerSuccess = 17
    case ping = 18
    case pong = 19
    case redeliverUnacknowledgedMessages = 20
    case partitionedMetadata = 21
    case partitionedMetadataResponse = 22
    case lookup = 23
    case lookupResponse = 24
    case consumerStats = 25
    case consumerStatsResponse = 26
    case reachedEndOfTopic = 27
    case seek = 28
    case getLastMessageID = 29
    case getLastMessageIDResponse = 30
    case activeConsumerChange = 31
    case getTopicsOfNamespace = 32
    case getTopicsOfNamespaceResponse = 33
    case getSchema = 34
    case getSchemaResponse = 35
    case authChallenge = 36
    case authResponse = 37
    case ackResponse = 38
    case getOrCreateSchema = 39
    case getOrCreateSchemaResponse = 40

    /// transaction related
    case newTxn = 50
    case newTxnResponse = 51
    case addPartitionToTxn = 52
    case addPartitionToTxnResponse = 53
    case addSubscriptionToTxn = 54
    case addSubscriptionToTxnResponse = 55
    case endTxn = 56
    case endTxnResponse = 57
    case endTxnOnPartition = 58
    case endTxnOnPartitionResponse = 59
    case endTxnOnSubscription = 60
    case endTxnOnSubscriptionResponse = 61
    case tcClientConnectRequest = 62
    case tcClientConnectResponse = 63
    case watchTopicList = 64
    case watchTopicListSuccess = 65
    case watchTopicUpdate = 66
    case watchTopicListClose = 67
    case topicMigrated = 68

    public init() {
      self = .connect
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pulsar.proto"

extension Pulsar_Proto_CompressionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "LZ4"),
    2: .same(proto: "ZLIB"),
    3: .same(proto: "ZSTD"),
    4: .same(proto: "SNAPPY"),
  ]
}

extension Pulsar_Proto_ProducerAccessMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Shared"),
    1: .same(proto: "Exclusive"),
    2: .same(proto: "WaitForExclusive"),
    3: .same(proto: "ExclusiveWithFencing"),
  ]
}

extension Pulsar_Proto_ServerError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownError"),
    1: .same(proto: "MetadataError"),
    2: .same(proto: "PersistenceError"),
    3: .same(proto: "AuthenticationError"),
    4: .same(proto: "AuthorizationError"),
    5: .same(proto: "ConsumerBusy"),
    6: .same(proto: "ServiceNotReady"),
    7: .same(proto: "ProducerBlockedQuotaExceededError"),
    8: .same(proto: "ProducerBlockedQuotaExceededException"),
    9: .same(proto: "ChecksumError"),
    10: .same(proto: "UnsupportedVersionError"),
    11: .same(proto: "TopicNotFound"),
    12: .same(proto: "SubscriptionNotFound"),
    13: .same(proto: "ConsumerNotFound"),
    14: .same(proto: "TooManyRequests"),
    15: .same(proto: "TopicTerminatedError"),
    16: .same(proto: "ProducerBusy"),
    17: .same(proto: "InvalidTopicName"),
    18: .same(proto: "IncompatibleSchema"),
    19: .same(proto: "ConsumerAssignError"),
    20: .same(proto: "TransactionCoordinatorNotFound"),
    21: .same(proto: "InvalidTxnStatus"),
    22: .same(proto: "NotAllowedError"),
    23: .same(proto: "TransactionConflict"),
    24: .same(proto: "TransactionNotFound"),
    25: .same(proto: "ProducerFenced"),
  ]
}

extension Pulsar_Proto_AuthMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AuthMethodNone"),
    1: .same(proto: "AuthMethodYcaV1"),
    2: .same(proto: "AuthMethodAthens"),
  ]
}

extension Pulsar_Proto_ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "v0"),
    1: .same(proto: "v1"),
    2: .same(proto: "v2"),
    3: .same(proto: "v3"),
    4: .same(proto: "v4"),
    5: .same(proto: "v5"),
    6: .same(proto: "v6"),
    7: .same(proto: "v7"),
    8: .same(proto: "v8"),
    9: .same(proto: "v9"),
    10: .same(proto: "v10"),
    11: .same(proto: "v11"),
    12: .same(proto: "v12"),
    13: .same(proto: "v13"),
    14: .same(proto: "v14"),
    15: .same(proto: "v15"),
    16: .same(proto: "v16"),
    17: .same(proto: "v17"),
    18: .same(proto: "v18"),
    19: .same(proto: "v19"),
    20: .same(proto: "v20"),
    21: .same(proto: "v21"),
  ]
}

extension Pulsar_Proto_KeySharedMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTO_SPLIT"),
    1: .same(proto: "STICKY"),
  ]
}

extension Pulsar_Proto_TxnAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMIT"),
    1: .same(proto: "ABORT"),
  ]
}

extension Pulsar_Proto_Schema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schema"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "schema_data"),
    4: .same(proto: "type"),
    5: .same(proto: "properties"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._schemaData == nil {return false}
    if self._type == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._schemaData) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._schemaData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_Schema, rhs: Pulsar_Proto_Schema) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._schemaData != rhs._schemaData {return false}
    if lhs._type != rhs._type {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_Schema.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "String"),
    2: .same(proto: "Json"),
    3: .same(proto: "Protobuf"),
    4: .same(proto: "Avro"),
    5: .same(proto: "Bool"),
    6: .same(proto: "Int8"),
    7: .same(proto: "Int16"),
    8: .same(proto: "Int32"),
    9: .same(proto: "Int64"),
    10: .same(proto: "Float"),
    11: .same(proto: "Double"),
    12: .same(proto: "Date"),
    13: .same(proto: "Time"),
    14: .same(proto: "Timestamp"),
    15: .same(proto: "KeyValue"),
    16: .same(proto: "Instant"),
    17: .same(proto: "LocalDate"),
    18: .same(proto: "LocalTime"),
    19: .same(proto: "LocalDateTime"),
    20: .same(proto: "ProtobufNative"),
    21: .same(proto: "AutoConsume"),
  ]
}

extension Pulsar_Proto_MessageIdData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageIdData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ledgerId"),
    2: .same(proto: "entryId"),
    3: .same(proto: "partition"),
    4: .standard(proto: "batch_index"),
    5: .standard(proto: "ack_set"),
    6: .standard(proto: "batch_size"),
    7: .standard(proto: "first_chunk_message_id"),
  ]

  fileprivate class _StorageClass {
    var _ledgerID: UInt64? = nil
    var _entryID: UInt64? = nil
    var _partition: Int32? = nil
    var _batchIndex: Int32? = nil
    var _ackSet: [Int64] = []
    var _batchSize: Int32? = nil
    var _firstChunkMessageID: Pulsar_Proto_MessageIdData? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ledgerID = source._ledgerID
      _entryID = source._entryID
      _partition = source._partition
      _batchIndex = source._batchIndex
      _ackSet = source._ackSet
      _batchSize = source._batchSize
      _firstChunkMessageID = source._firstChunkMessageID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ledgerID == nil {return false}
      if _storage._entryID == nil {return false}
      if let v = _storage._firstChunkMessageID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._ledgerID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._entryID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._partition) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._batchIndex) }()
        case 5: try { try decoder.decodeRepeatedInt64Field(value: &_storage._ackSet) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._batchSize) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._firstChunkMessageID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._ledgerID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._entryID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._partition {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._batchIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      if !_storage._ackSet.isEmpty {
        try visitor.visitRepeatedInt64Field(value: _storage._ackSet, fieldNumber: 5)
      }
      try { if let v = _storage._batchSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._firstChunkMessageID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_MessageIdData, rhs: Pulsar_Proto_MessageIdData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ledgerID != rhs_storage._ledgerID {return false}
        if _storage._entryID != rhs_storage._entryID {return false}
        if _storage._partition != rhs_storage._partition {return false}
        if _storage._batchIndex != rhs_storage._batchIndex {return false}
        if _storage._ackSet != rhs_storage._ackSet {return false}
        if _storage._batchSize != rhs_storage._batchSize {return false}
        if _storage._firstChunkMessageID != rhs_storage._firstChunkMessageID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_KeyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_KeyValue, rhs: Pulsar_Proto_KeyValue) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_KeyLongValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyLongValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_KeyLongValue, rhs: Pulsar_Proto_KeyLongValue) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_IntRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public var isInitialized: Bool {
    if self._start == nil {return false}
    if self._end == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_IntRange, rhs: Pulsar_Proto_IntRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_EncryptionKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptionKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "metadata"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.metadata) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._value) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_EncryptionKeys, rhs: Pulsar_Proto_EncryptionKeys) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_MessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "producer_name"),
    2: .standard(proto: "sequence_id"),
    3: .standard(proto: "publish_time"),
    4: .same(proto: "properties"),
    5: .standard(proto: "replicated_from"),
    6: .standard(proto: "partition_key"),
    7: .standard(proto: "replicate_to"),
    8: .same(proto: "compression"),
    9: .standard(proto: "uncompressed_size"),
    11: .standard(proto: "num_messages_in_batch"),
    12: .standard(proto: "event_time"),
    13: .standard(proto: "encryption_keys"),
    14: .standard(proto: "encryption_algo"),
    15: .standard(proto: "encryption_param"),
    16: .standard(proto: "schema_version"),
    17: .standard(proto: "partition_key_b64_encoded"),
    18: .standard(proto: "ordering_key"),
    19: .standard(proto: "deliver_at_time"),
    20: .standard(proto: "marker_type"),
    22: .standard(proto: "txnid_least_bits"),
    23: .standard(proto: "txnid_most_bits"),
    24: .standard(proto: "highest_sequence_id"),
    25: .standard(proto: "null_value"),
    26: .same(proto: "uuid"),
    27: .standard(proto: "num_chunks_from_msg"),
    28: .standard(proto: "total_chunk_msg_size"),
    29: .standard(proto: "chunk_id"),
    30: .standard(proto: "null_partition_key"),
  ]

  fileprivate class _StorageClass {
    var _producerName: String? = nil
    var _sequenceID: UInt64? = nil
    var _publishTime: UInt64? = nil
    var _properties: [Pulsar_Proto_KeyValue] = []
    var _replicatedFrom: String? = nil
    var _partitionKey: String? = nil
    var _replicateTo: [String] = []
    var _compression: Pulsar_Proto_CompressionType? = nil
    var _uncompressedSize: UInt32? = nil
    var _numMessagesInBatch: Int32? = nil
    var _eventTime: UInt64? = nil
    var _encryptionKeys: [Pulsar_Proto_EncryptionKeys] = []
    var _encryptionAlgo: String? = nil
    var _encryptionParam: Data? = nil
    var _schemaVersion: Data? = nil
    var _partitionKeyB64Encoded: Bool? = nil
    var _orderingKey: Data? = nil
    var _deliverAtTime: Int64? = nil
    var _markerType: Int32? = nil
    var _txnidLeastBits: UInt64? = nil
    var _txnidMostBits: UInt64? = nil
    var _highestSequenceID: UInt64? = nil
    var _nullValue: Bool? = nil
    var _uuid: String? = nil
    var _numChunksFromMsg: Int32? = nil
    var _totalChunkMsgSize: Int32? = nil
    var _chunkID: Int32? = nil
    var _nullPartitionKey: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _producerName = source._producerName
      _sequenceID = source._sequenceID
      _publishTime = source._publishTime
      _properties = source._properties
      _replicatedFrom = source._replicatedFrom
      _partitionKey = source._partitionKey
      _replicateTo = source._replicateTo
      _compression = source._compression
      _uncompressedSize = source._uncompressedSize
      _numMessagesInBatch = source._numMessagesInBatch
      _eventTime = source._eventTime
      _encryptionKeys = source._encryptionKeys
      _encryptionAlgo = source._encryptionAlgo
      _encryptionParam = source._encryptionParam
      _schemaVersion = source._schemaVersion
      _partitionKeyB64Encoded = source._partitionKeyB64Encoded
      _orderingKey = source._orderingKey
      _deliverAtTime = source._deliverAtTime
      _markerType = source._markerType
      _txnidLeastBits = source._txnidLeastBits
      _txnidMostBits = source._txnidMostBits
      _highestSequenceID = source._highestSequenceID
      _nullValue = source._nullValue
      _uuid = source._uuid
      _numChunksFromMsg = source._numChunksFromMsg
      _totalChunkMsgSize = source._totalChunkMsgSize
      _chunkID = source._chunkID
      _nullPartitionKey = source._nullPartitionKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._producerName == nil {return false}
      if _storage._sequenceID == nil {return false}
      if _storage._publishTime == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._properties) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._encryptionKeys) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._producerName) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._sequenceID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._publishTime) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._properties) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._replicatedFrom) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._partitionKey) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._replicateTo) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._compression) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._uncompressedSize) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._numMessagesInBatch) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._eventTime) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._encryptionKeys) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._encryptionAlgo) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._encryptionParam) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._schemaVersion) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._partitionKeyB64Encoded) }()
        case 18: try { try decoder.decodeSingularBytesField(value: &_storage._orderingKey) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._deliverAtTime) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._markerType) }()
        case 22: try { try decoder.decodeSingularUInt64Field(value: &_storage._txnidLeastBits) }()
        case 23: try { try decoder.decodeSingularUInt64Field(value: &_storage._txnidMostBits) }()
        case 24: try { try decoder.decodeSingularUInt64Field(value: &_storage._highestSequenceID) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._nullValue) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 27: try { try decoder.decodeSingularInt32Field(value: &_storage._numChunksFromMsg) }()
        case 28: try { try decoder.decodeSingularInt32Field(value: &_storage._totalChunkMsgSize) }()
        case 29: try { try decoder.decodeSingularInt32Field(value: &_storage._chunkID) }()
        case 30: try { try decoder.decodeSingularBoolField(value: &_storage._nullPartitionKey) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._producerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sequenceID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._publishTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      if !_storage._properties.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._properties, fieldNumber: 4)
      }
      try { if let v = _storage._replicatedFrom {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._partitionKey {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      if !_storage._replicateTo.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._replicateTo, fieldNumber: 7)
      }
      try { if let v = _storage._compression {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._uncompressedSize {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._numMessagesInBatch {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._eventTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
      } }()
      if !_storage._encryptionKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._encryptionKeys, fieldNumber: 13)
      }
      try { if let v = _storage._encryptionAlgo {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._encryptionParam {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._schemaVersion {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._partitionKeyB64Encoded {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._orderingKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._deliverAtTime {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._markerType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._txnidLeastBits {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._txnidMostBits {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._highestSequenceID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._nullValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._uuid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._numChunksFromMsg {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._totalChunkMsgSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._chunkID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._nullPartitionKey {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 30)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_MessageMetadata, rhs: Pulsar_Proto_MessageMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._producerName != rhs_storage._producerName {return false}
        if _storage._sequenceID != rhs_storage._sequenceID {return false}
        if _storage._publishTime != rhs_storage._publishTime {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._replicatedFrom != rhs_storage._replicatedFrom {return false}
        if _storage._partitionKey != rhs_storage._partitionKey {return false}
        if _storage._replicateTo != rhs_storage._replicateTo {return false}
        if _storage._compression != rhs_storage._compression {return false}
        if _storage._uncompressedSize != rhs_storage._uncompressedSize {return false}
        if _storage._numMessagesInBatch != rhs_storage._numMessagesInBatch {return false}
        if _storage._eventTime != rhs_storage._eventTime {return false}
        if _storage._encryptionKeys != rhs_storage._encryptionKeys {return false}
        if _storage._encryptionAlgo != rhs_storage._encryptionAlgo {return false}
        if _storage._encryptionParam != rhs_storage._encryptionParam {return false}
        if _storage._schemaVersion != rhs_storage._schemaVersion {return false}
        if _storage._partitionKeyB64Encoded != rhs_storage._partitionKeyB64Encoded {return false}
        if _storage._orderingKey != rhs_storage._orderingKey {return false}
        if _storage._deliverAtTime != rhs_storage._deliverAtTime {return false}
        if _storage._markerType != rhs_storage._markerType {return false}
        if _storage._txnidLeastBits != rhs_storage._txnidLeastBits {return false}
        if _storage._txnidMostBits != rhs_storage._txnidMostBits {return false}
        if _storage._highestSequenceID != rhs_storage._highestSequenceID {return false}
        if _storage._nullValue != rhs_storage._nullValue {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._numChunksFromMsg != rhs_storage._numChunksFromMsg {return false}
        if _storage._totalChunkMsgSize != rhs_storage._totalChunkMsgSize {return false}
        if _storage._chunkID != rhs_storage._chunkID {return false}
        if _storage._nullPartitionKey != rhs_storage._nullPartitionKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_SingleMessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleMessageMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
    2: .standard(proto: "partition_key"),
    3: .standard(proto: "payload_size"),
    4: .standard(proto: "compacted_out"),
    5: .standard(proto: "event_time"),
    6: .standard(proto: "partition_key_b64_encoded"),
    7: .standard(proto: "ordering_key"),
    8: .standard(proto: "sequence_id"),
    9: .standard(proto: "null_value"),
    10: .standard(proto: "null_partition_key"),
  ]

  public var isInitialized: Bool {
    if self._payloadSize == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._partitionKey) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._payloadSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._compactedOut) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._eventTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._partitionKeyB64Encoded) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._orderingKey) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._sequenceID) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._nullValue) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._nullPartitionKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 1)
    }
    try { if let v = self._partitionKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payloadSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._compactedOut {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._eventTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._partitionKeyB64Encoded {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._orderingKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._sequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._nullValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._nullPartitionKey {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_SingleMessageMetadata, rhs: Pulsar_Proto_SingleMessageMetadata) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs._partitionKey != rhs._partitionKey {return false}
    if lhs._payloadSize != rhs._payloadSize {return false}
    if lhs._compactedOut != rhs._compactedOut {return false}
    if lhs._eventTime != rhs._eventTime {return false}
    if lhs._partitionKeyB64Encoded != rhs._partitionKeyB64Encoded {return false}
    if lhs._orderingKey != rhs._orderingKey {return false}
    if lhs._sequenceID != rhs._sequenceID {return false}
    if lhs._nullValue != rhs._nullValue {return false}
    if lhs._nullPartitionKey != rhs._nullPartitionKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_BrokerEntryMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrokerEntryMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "broker_timestamp"),
    2: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._brokerTimestamp) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._brokerTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._index {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_BrokerEntryMetadata, rhs: Pulsar_Proto_BrokerEntryMetadata) -> Bool {
    if lhs._brokerTimestamp != rhs._brokerTimestamp {return false}
    if lhs._index != rhs._index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandConnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandConnect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_version"),
    2: .standard(proto: "auth_method"),
    5: .standard(proto: "auth_method_name"),
    3: .standard(proto: "auth_data"),
    4: .standard(proto: "protocol_version"),
    6: .standard(proto: "proxy_to_broker_url"),
    7: .standard(proto: "original_principal"),
    8: .standard(proto: "original_auth_data"),
    9: .standard(proto: "original_auth_method"),
    10: .standard(proto: "feature_flags"),
    11: .standard(proto: "proxy_version"),
  ]

  public var isInitialized: Bool {
    if self._clientVersion == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._clientVersion) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._authMethod) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._authData) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._protocolVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._authMethodName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._proxyToBrokerURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._originalPrincipal) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._originalAuthData) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._originalAuthMethod) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._featureFlags) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._proxyVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clientVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authMethod {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._authData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._protocolVersion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._authMethodName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._proxyToBrokerURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._originalPrincipal {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._originalAuthData {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._originalAuthMethod {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._featureFlags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._proxyVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandConnect, rhs: Pulsar_Proto_CommandConnect) -> Bool {
    if lhs._clientVersion != rhs._clientVersion {return false}
    if lhs._authMethod != rhs._authMethod {return false}
    if lhs._authMethodName != rhs._authMethodName {return false}
    if lhs._authData != rhs._authData {return false}
    if lhs._protocolVersion != rhs._protocolVersion {return false}
    if lhs._proxyToBrokerURL != rhs._proxyToBrokerURL {return false}
    if lhs._originalPrincipal != rhs._originalPrincipal {return false}
    if lhs._originalAuthData != rhs._originalAuthData {return false}
    if lhs._originalAuthMethod != rhs._originalAuthMethod {return false}
    if lhs._featureFlags != rhs._featureFlags {return false}
    if lhs._proxyVersion != rhs._proxyVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_FeatureFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supports_auth_refresh"),
    2: .standard(proto: "supports_broker_entry_metadata"),
    3: .standard(proto: "supports_partial_producer"),
    4: .standard(proto: "supports_topic_watchers"),
    5: .standard(proto: "supports_get_partitioned_metadata_without_auto_creation"),
    6: .standard(proto: "supports_repl_dedup_by_lid_and_eid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._supportsAuthRefresh) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._supportsBrokerEntryMetadata) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._supportsPartialProducer) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._supportsTopicWatchers) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._supportsGetPartitionedMetadataWithoutAutoCreation) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._supportsReplDedupByLidAndEid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._supportsAuthRefresh {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._supportsBrokerEntryMetadata {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._supportsPartialProducer {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._supportsTopicWatchers {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._supportsGetPartitionedMetadataWithoutAutoCreation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._supportsReplDedupByLidAndEid {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_FeatureFlags, rhs: Pulsar_Proto_FeatureFlags) -> Bool {
    if lhs._supportsAuthRefresh != rhs._supportsAuthRefresh {return false}
    if lhs._supportsBrokerEntryMetadata != rhs._supportsBrokerEntryMetadata {return false}
    if lhs._supportsPartialProducer != rhs._supportsPartialProducer {return false}
    if lhs._supportsTopicWatchers != rhs._supportsTopicWatchers {return false}
    if lhs._supportsGetPartitionedMetadataWithoutAutoCreation != rhs._supportsGetPartitionedMetadataWithoutAutoCreation {return false}
    if lhs._supportsReplDedupByLidAndEid != rhs._supportsReplDedupByLidAndEid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandConnected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandConnected"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_version"),
    2: .standard(proto: "protocol_version"),
    3: .standard(proto: "max_message_size"),
    4: .standard(proto: "feature_flags"),
  ]

  public var isInitialized: Bool {
    if self._serverVersion == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._serverVersion) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._protocolVersion) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._maxMessageSize) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._featureFlags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serverVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._protocolVersion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxMessageSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._featureFlags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandConnected, rhs: Pulsar_Proto_CommandConnected) -> Bool {
    if lhs._serverVersion != rhs._serverVersion {return false}
    if lhs._protocolVersion != rhs._protocolVersion {return false}
    if lhs._maxMessageSize != rhs._maxMessageSize {return false}
    if lhs._featureFlags != rhs._featureFlags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAuthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_version"),
    2: .same(proto: "response"),
    3: .standard(proto: "protocol_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._clientVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._protocolVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clientVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._protocolVersion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAuthResponse, rhs: Pulsar_Proto_CommandAuthResponse) -> Bool {
    if lhs._clientVersion != rhs._clientVersion {return false}
    if lhs._response != rhs._response {return false}
    if lhs._protocolVersion != rhs._protocolVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAuthChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAuthChallenge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_version"),
    2: .same(proto: "challenge"),
    3: .standard(proto: "protocol_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._serverVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._challenge) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._protocolVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serverVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._challenge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._protocolVersion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAuthChallenge, rhs: Pulsar_Proto_CommandAuthChallenge) -> Bool {
    if lhs._serverVersion != rhs._serverVersion {return false}
    if lhs._challenge != rhs._challenge {return false}
    if lhs._protocolVersion != rhs._protocolVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_AuthData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_method_name"),
    2: .standard(proto: "auth_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._authMethodName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._authData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authMethodName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_AuthData, rhs: Pulsar_Proto_AuthData) -> Bool {
    if lhs._authMethodName != rhs._authMethodName {return false}
    if lhs._authData != rhs._authData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_KeySharedMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeySharedMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keySharedMode"),
    3: .same(proto: "hashRanges"),
    4: .same(proto: "allowOutOfOrderDelivery"),
  ]

  public var isInitialized: Bool {
    if self._keySharedMode == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.hashRanges) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._keySharedMode) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.hashRanges) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._allowOutOfOrderDelivery) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keySharedMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.hashRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hashRanges, fieldNumber: 3)
    }
    try { if let v = self._allowOutOfOrderDelivery {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_KeySharedMeta, rhs: Pulsar_Proto_KeySharedMeta) -> Bool {
    if lhs._keySharedMode != rhs._keySharedMode {return false}
    if lhs.hashRanges != rhs.hashRanges {return false}
    if lhs._allowOutOfOrderDelivery != rhs._allowOutOfOrderDelivery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandSubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "subscription"),
    3: .same(proto: "subType"),
    4: .standard(proto: "consumer_id"),
    5: .standard(proto: "request_id"),
    6: .standard(proto: "consumer_name"),
    7: .standard(proto: "priority_level"),
    8: .same(proto: "durable"),
    9: .standard(proto: "start_message_id"),
    10: .same(proto: "metadata"),
    11: .standard(proto: "read_compacted"),
    12: .same(proto: "schema"),
    13: .same(proto: "initialPosition"),
    14: .standard(proto: "replicate_subscription_state"),
    15: .standard(proto: "force_topic_creation"),
    16: .standard(proto: "start_message_rollback_duration_sec"),
    17: .same(proto: "keySharedMeta"),
    18: .standard(proto: "subscription_properties"),
    19: .standard(proto: "consumer_epoch"),
  ]

  fileprivate class _StorageClass {
    var _topic: String? = nil
    var _subscription: String? = nil
    var _subType: Pulsar_Proto_CommandSubscribe.SubType? = nil
    var _consumerID: UInt64? = nil
    var _requestID: UInt64? = nil
    var _consumerName: String? = nil
    var _priorityLevel: Int32? = nil
    var _durable: Bool? = nil
    var _startMessageID: Pulsar_Proto_MessageIdData? = nil
    var _metadata: [Pulsar_Proto_KeyValue] = []
    var _readCompacted: Bool? = nil
    var _schema: Pulsar_Proto_Schema? = nil
    var _initialPosition: Pulsar_Proto_CommandSubscribe.InitialPosition? = nil
    var _replicateSubscriptionState: Bool? = nil
    var _forceTopicCreation: Bool? = nil
    var _startMessageRollbackDurationSec: UInt64? = nil
    var _keySharedMeta: Pulsar_Proto_KeySharedMeta? = nil
    var _subscriptionProperties: [Pulsar_Proto_KeyValue] = []
    var _consumerEpoch: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topic = source._topic
      _subscription = source._subscription
      _subType = source._subType
      _consumerID = source._consumerID
      _requestID = source._requestID
      _consumerName = source._consumerName
      _priorityLevel = source._priorityLevel
      _durable = source._durable
      _startMessageID = source._startMessageID
      _metadata = source._metadata
      _readCompacted = source._readCompacted
      _schema = source._schema
      _initialPosition = source._initialPosition
      _replicateSubscriptionState = source._replicateSubscriptionState
      _forceTopicCreation = source._forceTopicCreation
      _startMessageRollbackDurationSec = source._startMessageRollbackDurationSec
      _keySharedMeta = source._keySharedMeta
      _subscriptionProperties = source._subscriptionProperties
      _consumerEpoch = source._consumerEpoch
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._topic == nil {return false}
      if _storage._subscription == nil {return false}
      if _storage._subType == nil {return false}
      if _storage._consumerID == nil {return false}
      if _storage._requestID == nil {return false}
      if let v = _storage._startMessageID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._metadata) {return false}
      if let v = _storage._schema, !v.isInitialized {return false}
      if let v = _storage._keySharedMeta, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._subscriptionProperties) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._topic) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subscription) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._subType) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._consumerID) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._requestID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._consumerName) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._priorityLevel) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._durable) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startMessageID) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._metadata) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._readCompacted) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._schema) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._initialPosition) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._replicateSubscriptionState) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._forceTopicCreation) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._startMessageRollbackDurationSec) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._keySharedMeta) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._subscriptionProperties) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._consumerEpoch) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._topic {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._subscription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._subType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._consumerID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._requestID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._consumerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._priorityLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._durable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._startMessageID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._metadata.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metadata, fieldNumber: 10)
      }
      try { if let v = _storage._readCompacted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._schema {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._initialPosition {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._replicateSubscriptionState {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._forceTopicCreation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._startMessageRollbackDurationSec {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._keySharedMeta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._subscriptionProperties.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subscriptionProperties, fieldNumber: 18)
      }
      try { if let v = _storage._consumerEpoch {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandSubscribe, rhs: Pulsar_Proto_CommandSubscribe) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._subscription != rhs_storage._subscription {return false}
        if _storage._subType != rhs_storage._subType {return false}
        if _storage._consumerID != rhs_storage._consumerID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._consumerName != rhs_storage._consumerName {return false}
        if _storage._priorityLevel != rhs_storage._priorityLevel {return false}
        if _storage._durable != rhs_storage._durable {return false}
        if _storage._startMessageID != rhs_storage._startMessageID {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._readCompacted != rhs_storage._readCompacted {return false}
        if _storage._schema != rhs_storage._schema {return false}
        if _storage._initialPosition != rhs_storage._initialPosition {return false}
        if _storage._replicateSubscriptionState != rhs_storage._replicateSubscriptionState {return false}
        if _storage._forceTopicCreation != rhs_storage._forceTopicCreation {return false}
        if _storage._startMessageRollbackDurationSec != rhs_storage._startMessageRollbackDurationSec {return false}
        if _storage._keySharedMeta != rhs_storage._keySharedMeta {return false}
        if _storage._subscriptionProperties != rhs_storage._subscriptionProperties {return false}
        if _storage._consumerEpoch != rhs_storage._consumerEpoch {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandSubscribe.SubType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Exclusive"),
    1: .same(proto: "Shared"),
    2: .same(proto: "Failover"),
    3: .same(proto: "Key_Shared"),
  ]
}

extension Pulsar_Proto_CommandSubscribe.InitialPosition: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Latest"),
    1: .same(proto: "Earliest"),
  ]
}

extension Pulsar_Proto_CommandPartitionedTopicMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandPartitionedTopicMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "request_id"),
    3: .standard(proto: "original_principal"),
    4: .standard(proto: "original_auth_data"),
    5: .standard(proto: "original_auth_method"),
    6: .standard(proto: "metadata_auto_creation_enabled"),
  ]

  public var isInitialized: Bool {
    if self._topic == nil {return false}
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._originalPrincipal) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._originalAuthData) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._originalAuthMethod) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._metadataAutoCreationEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originalPrincipal {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._originalAuthData {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._originalAuthMethod {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._metadataAutoCreationEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandPartitionedTopicMetadata, rhs: Pulsar_Proto_CommandPartitionedTopicMetadata) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._originalPrincipal != rhs._originalPrincipal {return false}
    if lhs._originalAuthData != rhs._originalAuthData {return false}
    if lhs._originalAuthMethod != rhs._originalAuthMethod {return false}
    if lhs._metadataAutoCreationEnabled != rhs._metadataAutoCreationEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandPartitionedTopicMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandPartitionedTopicMetadataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partitions"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "response"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._partitions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._response) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._partitions {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._response {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandPartitionedTopicMetadataResponse, rhs: Pulsar_Proto_CommandPartitionedTopicMetadataResponse) -> Bool {
    if lhs._partitions != rhs._partitions {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._response != rhs._response {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandPartitionedTopicMetadataResponse.LookupType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "Failed"),
  ]
}

extension Pulsar_Proto_CommandLookupTopic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandLookupTopic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "authoritative"),
    4: .standard(proto: "original_principal"),
    5: .standard(proto: "original_auth_data"),
    6: .standard(proto: "original_auth_method"),
    7: .standard(proto: "advertised_listener_name"),
    8: .same(proto: "properties"),
  ]

  public var isInitialized: Bool {
    if self._topic == nil {return false}
    if self._requestID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._authoritative) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._originalPrincipal) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._originalAuthData) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._originalAuthMethod) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._advertisedListenerName) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._authoritative {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._originalPrincipal {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._originalAuthData {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._originalAuthMethod {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._advertisedListenerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandLookupTopic, rhs: Pulsar_Proto_CommandLookupTopic) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._authoritative != rhs._authoritative {return false}
    if lhs._originalPrincipal != rhs._originalPrincipal {return false}
    if lhs._originalAuthData != rhs._originalAuthData {return false}
    if lhs._originalAuthMethod != rhs._originalAuthMethod {return false}
    if lhs._advertisedListenerName != rhs._advertisedListenerName {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandLookupTopicResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandLookupTopicResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brokerServiceUrl"),
    2: .same(proto: "brokerServiceUrlTls"),
    3: .same(proto: "response"),
    4: .standard(proto: "request_id"),
    5: .same(proto: "authoritative"),
    6: .same(proto: "error"),
    7: .same(proto: "message"),
    8: .standard(proto: "proxy_through_service_url"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._brokerServiceURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._brokerServiceURLTls) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._response) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._authoritative) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._proxyThroughServiceURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._brokerServiceURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._brokerServiceURLTls {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._response {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._authoritative {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._proxyThroughServiceURL {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandLookupTopicResponse, rhs: Pulsar_Proto_CommandLookupTopicResponse) -> Bool {
    if lhs._brokerServiceURL != rhs._brokerServiceURL {return false}
    if lhs._brokerServiceURLTls != rhs._brokerServiceURLTls {return false}
    if lhs._response != rhs._response {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._authoritative != rhs._authoritative {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs._proxyThroughServiceURL != rhs._proxyThroughServiceURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandLookupTopicResponse.LookupType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Redirect"),
    1: .same(proto: "Connect"),
    2: .same(proto: "Failed"),
  ]
}

extension Pulsar_Proto_CommandProducer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandProducer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "producer_id"),
    3: .standard(proto: "request_id"),
    4: .standard(proto: "producer_name"),
    5: .same(proto: "encrypted"),
    6: .same(proto: "metadata"),
    7: .same(proto: "schema"),
    8: .same(proto: "epoch"),
    9: .standard(proto: "user_provided_producer_name"),
    10: .standard(proto: "producer_access_mode"),
    11: .standard(proto: "topic_epoch"),
    12: .standard(proto: "txn_enabled"),
    13: .standard(proto: "initial_subscription_name"),
  ]

  public var isInitialized: Bool {
    if self._topic == nil {return false}
    if self._producerID == nil {return false}
    if self._requestID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.metadata) {return false}
    if let v = self._schema, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._producerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._producerName) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._encrypted) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._epoch) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._userProvidedProducerName) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self._producerAccessMode) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self._topicEpoch) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._txnEnabled) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._initialSubscriptionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._producerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._producerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._encrypted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 6)
    }
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._epoch {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._userProvidedProducerName {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._producerAccessMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._topicEpoch {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._txnEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._initialSubscriptionName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandProducer, rhs: Pulsar_Proto_CommandProducer) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._producerID != rhs._producerID {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._producerName != rhs._producerName {return false}
    if lhs._encrypted != rhs._encrypted {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._schema != rhs._schema {return false}
    if lhs._epoch != rhs._epoch {return false}
    if lhs._userProvidedProducerName != rhs._userProvidedProducerName {return false}
    if lhs._producerAccessMode != rhs._producerAccessMode {return false}
    if lhs._topicEpoch != rhs._topicEpoch {return false}
    if lhs._txnEnabled != rhs._txnEnabled {return false}
    if lhs._initialSubscriptionName != rhs._initialSubscriptionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandSend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "producer_id"),
    2: .standard(proto: "sequence_id"),
    3: .standard(proto: "num_messages"),
    4: .standard(proto: "txnid_least_bits"),
    5: .standard(proto: "txnid_most_bits"),
    6: .standard(proto: "highest_sequence_id"),
    7: .standard(proto: "is_chunk"),
    8: .same(proto: "marker"),
    9: .standard(proto: "message_id"),
  ]

  public var isInitialized: Bool {
    if self._producerID == nil {return false}
    if self._sequenceID == nil {return false}
    if let v = self._messageID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._producerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._sequenceID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._numMessages) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._highestSequenceID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._isChunk) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._marker) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._producerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._numMessages {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._highestSequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._isChunk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._marker {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandSend, rhs: Pulsar_Proto_CommandSend) -> Bool {
    if lhs._producerID != rhs._producerID {return false}
    if lhs._sequenceID != rhs._sequenceID {return false}
    if lhs._numMessages != rhs._numMessages {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._highestSequenceID != rhs._highestSequenceID {return false}
    if lhs._isChunk != rhs._isChunk {return false}
    if lhs._marker != rhs._marker {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandSendReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandSendReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "producer_id"),
    2: .standard(proto: "sequence_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "highest_sequence_id"),
  ]

  public var isInitialized: Bool {
    if self._producerID == nil {return false}
    if self._sequenceID == nil {return false}
    if let v = self._messageID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._producerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._sequenceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._highestSequenceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._producerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._highestSequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandSendReceipt, rhs: Pulsar_Proto_CommandSendReceipt) -> Bool {
    if lhs._producerID != rhs._producerID {return false}
    if lhs._sequenceID != rhs._sequenceID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._highestSequenceID != rhs._highestSequenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandSendError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandSendError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "producer_id"),
    2: .standard(proto: "sequence_id"),
    3: .same(proto: "error"),
    4: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._producerID == nil {return false}
    if self._sequenceID == nil {return false}
    if self._error == nil {return false}
    if self._message == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._producerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._sequenceID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._producerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandSendError, rhs: Pulsar_Proto_CommandSendError) -> Bool {
    if lhs._producerID != rhs._producerID {return false}
    if lhs._sequenceID != rhs._sequenceID {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "redelivery_count"),
    4: .standard(proto: "ack_set"),
    5: .standard(proto: "consumer_epoch"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if self._messageID == nil {return false}
    if let v = self._messageID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._redeliveryCount) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.ackSet) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._consumerEpoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._redeliveryCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.ackSet.isEmpty {
      try visitor.visitRepeatedInt64Field(value: self.ackSet, fieldNumber: 4)
    }
    try { if let v = self._consumerEpoch {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandMessage, rhs: Pulsar_Proto_CommandMessage) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._redeliveryCount != rhs._redeliveryCount {return false}
    if lhs.ackSet != rhs.ackSet {return false}
    if lhs._consumerEpoch != rhs._consumerEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "ack_type"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "validation_error"),
    5: .same(proto: "properties"),
    6: .standard(proto: "txnid_least_bits"),
    7: .standard(proto: "txnid_most_bits"),
    8: .standard(proto: "request_id"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if self._ackType == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.messageID) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._ackType) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._validationError) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ackType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.messageID.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageID, fieldNumber: 3)
    }
    try { if let v = self._validationError {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 5)
    }
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAck, rhs: Pulsar_Proto_CommandAck) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._ackType != rhs._ackType {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._validationError != rhs._validationError {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAck.AckType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Individual"),
    1: .same(proto: "Cumulative"),
  ]
}

extension Pulsar_Proto_CommandAck.ValidationError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UncompressedSizeCorruption"),
    1: .same(proto: "DecompressionError"),
    2: .same(proto: "ChecksumMismatch"),
    3: .same(proto: "BatchDeSerializeError"),
    4: .same(proto: "DecryptionError"),
  ]
}

extension Pulsar_Proto_CommandAckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAckResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
    6: .standard(proto: "request_id"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAckResponse, rhs: Pulsar_Proto_CommandAckResponse) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandActiveConsumerChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandActiveConsumerChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "is_active"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isActive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isActive {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandActiveConsumerChange, rhs: Pulsar_Proto_CommandActiveConsumerChange) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._isActive != rhs._isActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandFlow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandFlow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .same(proto: "messagePermits"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if self._messagePermits == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._messagePermits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._messagePermits {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandFlow, rhs: Pulsar_Proto_CommandFlow) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._messagePermits != rhs._messagePermits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandUnsubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "force"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._force {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandUnsubscribe, rhs: Pulsar_Proto_CommandUnsubscribe) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._force != rhs._force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandSeek: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandSeek"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "request_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "message_publish_time"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if self._requestID == nil {return false}
    if let v = self._messageID, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._messageID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._messagePublishTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._messagePublishTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandSeek, rhs: Pulsar_Proto_CommandSeek) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._messagePublishTime != rhs._messagePublishTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandReachedEndOfTopic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandReachedEndOfTopic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandReachedEndOfTopic, rhs: Pulsar_Proto_CommandReachedEndOfTopic) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandTopicMigrated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandTopicMigrated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_id"),
    2: .standard(proto: "resource_type"),
    3: .same(proto: "brokerServiceUrl"),
    4: .same(proto: "brokerServiceUrlTls"),
  ]

  public var isInitialized: Bool {
    if self._resourceID == nil {return false}
    if self._resourceType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._resourceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._resourceType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._brokerServiceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._brokerServiceURLTls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resourceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resourceType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._brokerServiceURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._brokerServiceURLTls {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandTopicMigrated, rhs: Pulsar_Proto_CommandTopicMigrated) -> Bool {
    if lhs._resourceID != rhs._resourceID {return false}
    if lhs._resourceType != rhs._resourceType {return false}
    if lhs._brokerServiceURL != rhs._brokerServiceURL {return false}
    if lhs._brokerServiceURLTls != rhs._brokerServiceURLTls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandTopicMigrated.ResourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Producer"),
    1: .same(proto: "Consumer"),
  ]
}

extension Pulsar_Proto_CommandCloseProducer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandCloseProducer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "producer_id"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "assignedBrokerServiceUrl"),
    4: .same(proto: "assignedBrokerServiceUrlTls"),
  ]

  public var isInitialized: Bool {
    if self._producerID == nil {return false}
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._producerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._assignedBrokerServiceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._assignedBrokerServiceURLTls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._producerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._assignedBrokerServiceURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._assignedBrokerServiceURLTls {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandCloseProducer, rhs: Pulsar_Proto_CommandCloseProducer) -> Bool {
    if lhs._producerID != rhs._producerID {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._assignedBrokerServiceURL != rhs._assignedBrokerServiceURL {return false}
    if lhs._assignedBrokerServiceURLTls != rhs._assignedBrokerServiceURLTls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandCloseConsumer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandCloseConsumer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "request_id"),
    3: .same(proto: "assignedBrokerServiceUrl"),
    4: .same(proto: "assignedBrokerServiceUrlTls"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._assignedBrokerServiceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._assignedBrokerServiceURLTls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._assignedBrokerServiceURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._assignedBrokerServiceURLTls {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandCloseConsumer, rhs: Pulsar_Proto_CommandCloseConsumer) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._assignedBrokerServiceURL != rhs._assignedBrokerServiceURL {return false}
    if lhs._assignedBrokerServiceURLTls != rhs._assignedBrokerServiceURLTls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandRedeliverUnacknowledgedMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandRedeliverUnacknowledgedMessages"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "message_ids"),
    3: .standard(proto: "consumer_epoch"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.messageIds) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messageIds) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._consumerEpoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.messageIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageIds, fieldNumber: 2)
    }
    try { if let v = self._consumerEpoch {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages, rhs: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs._consumerEpoch != rhs._consumerEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandSuccess"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "schema"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if let v = self._schema, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandSuccess, rhs: Pulsar_Proto_CommandSuccess) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._schema != rhs._schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandProducerSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandProducerSuccess"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "producer_name"),
    3: .standard(proto: "last_sequence_id"),
    4: .standard(proto: "schema_version"),
    5: .standard(proto: "topic_epoch"),
    6: .standard(proto: "producer_ready"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._producerName == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._producerName) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._lastSequenceID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._schemaVersion) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._topicEpoch) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._producerReady) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._producerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastSequenceID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._schemaVersion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._topicEpoch {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._producerReady {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandProducerSuccess, rhs: Pulsar_Proto_CommandProducerSuccess) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._producerName != rhs._producerName {return false}
    if lhs._lastSequenceID != rhs._lastSequenceID {return false}
    if lhs._schemaVersion != rhs._schemaVersion {return false}
    if lhs._topicEpoch != rhs._topicEpoch {return false}
    if lhs._producerReady != rhs._producerReady {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "error"),
    3: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._error == nil {return false}
    if self._message == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandError, rhs: Pulsar_Proto_CommandError) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandPing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandPing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandPing, rhs: Pulsar_Proto_CommandPing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandPong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandPong"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandPong, rhs: Pulsar_Proto_CommandPong) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandConsumerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandConsumerStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    4: .standard(proto: "consumer_id"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._consumerID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandConsumerStats, rhs: Pulsar_Proto_CommandConsumerStats) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandConsumerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandConsumerStatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "error_code"),
    3: .standard(proto: "error_message"),
    4: .same(proto: "msgRateOut"),
    5: .same(proto: "msgThroughputOut"),
    6: .same(proto: "msgRateRedeliver"),
    7: .same(proto: "consumerName"),
    8: .same(proto: "availablePermits"),
    9: .same(proto: "unackedMessages"),
    10: .same(proto: "blockedConsumerOnUnackedMsgs"),
    11: .same(proto: "address"),
    12: .same(proto: "connectedSince"),
    13: .same(proto: "type"),
    14: .same(proto: "msgRateExpired"),
    15: .same(proto: "msgBacklog"),
    16: .same(proto: "messageAckRate"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._errorCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._errorMessage) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._msgRateOut) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._msgThroughputOut) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._msgRateRedeliver) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._consumerName) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._availablePermits) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._unackedMessages) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._blockedConsumerOnUnackedMsgs) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._address) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._connectedSince) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._type) }()
      case 14: try { try decoder.decodeSingularDoubleField(value: &self._msgRateExpired) }()
      case 15: try { try decoder.decodeSingularUInt64Field(value: &self._msgBacklog) }()
      case 16: try { try decoder.decodeSingularDoubleField(value: &self._messageAckRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._errorCode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._errorMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._msgRateOut {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._msgThroughputOut {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._msgRateRedeliver {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._consumerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._availablePermits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._unackedMessages {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._blockedConsumerOnUnackedMsgs {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._connectedSince {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._msgRateExpired {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._msgBacklog {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._messageAckRate {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandConsumerStatsResponse, rhs: Pulsar_Proto_CommandConsumerStatsResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._errorCode != rhs._errorCode {return false}
    if lhs._errorMessage != rhs._errorMessage {return false}
    if lhs._msgRateOut != rhs._msgRateOut {return false}
    if lhs._msgThroughputOut != rhs._msgThroughputOut {return false}
    if lhs._msgRateRedeliver != rhs._msgRateRedeliver {return false}
    if lhs._consumerName != rhs._consumerName {return false}
    if lhs._availablePermits != rhs._availablePermits {return false}
    if lhs._unackedMessages != rhs._unackedMessages {return false}
    if lhs._blockedConsumerOnUnackedMsgs != rhs._blockedConsumerOnUnackedMsgs {return false}
    if lhs._address != rhs._address {return false}
    if lhs._connectedSince != rhs._connectedSince {return false}
    if lhs._type != rhs._type {return false}
    if lhs._msgRateExpired != rhs._msgRateExpired {return false}
    if lhs._msgBacklog != rhs._msgBacklog {return false}
    if lhs._messageAckRate != rhs._messageAckRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetLastMessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetLastMessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
    2: .standard(proto: "request_id"),
  ]

  public var isInitialized: Bool {
    if self._consumerID == nil {return false}
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._consumerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consumerID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetLastMessageId, rhs: Pulsar_Proto_CommandGetLastMessageId) -> Bool {
    if lhs._consumerID != rhs._consumerID {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetLastMessageIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetLastMessageIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_message_id"),
    2: .standard(proto: "request_id"),
    3: .standard(proto: "consumer_mark_delete_position"),
  ]

  public var isInitialized: Bool {
    if self._lastMessageID == nil {return false}
    if self._requestID == nil {return false}
    if let v = self._lastMessageID, !v.isInitialized {return false}
    if let v = self._consumerMarkDeletePosition, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastMessageID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consumerMarkDeletePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastMessageID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._consumerMarkDeletePosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetLastMessageIdResponse, rhs: Pulsar_Proto_CommandGetLastMessageIdResponse) -> Bool {
    if lhs._lastMessageID != rhs._lastMessageID {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs._consumerMarkDeletePosition != rhs._consumerMarkDeletePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetTopicsOfNamespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetTopicsOfNamespace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "namespace"),
    3: .same(proto: "mode"),
    4: .standard(proto: "topics_pattern"),
    5: .standard(proto: "topics_hash"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._namespace == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._namespace) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._topicsPattern) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._topicsHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._namespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._topicsPattern {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._topicsHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetTopicsOfNamespace, rhs: Pulsar_Proto_CommandGetTopicsOfNamespace) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._namespace != rhs._namespace {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs._topicsPattern != rhs._topicsPattern {return false}
    if lhs._topicsHash != rhs._topicsHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetTopicsOfNamespace.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERSISTENT"),
    1: .same(proto: "NON_PERSISTENT"),
    2: .same(proto: "ALL"),
  ]
}

extension Pulsar_Proto_CommandGetTopicsOfNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetTopicsOfNamespaceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "topics"),
    3: .same(proto: "filtered"),
    4: .standard(proto: "topics_hash"),
    5: .same(proto: "changed"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.topics) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._filtered) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._topicsHash) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._changed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.topics.isEmpty {
      try visitor.visitRepeatedStringField(value: self.topics, fieldNumber: 2)
    }
    try { if let v = self._filtered {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._topicsHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._changed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse, rhs: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs._filtered != rhs._filtered {return false}
    if lhs._topicsHash != rhs._topicsHash {return false}
    if lhs._changed != rhs._changed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandWatchTopicList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "watcher_id"),
    3: .same(proto: "namespace"),
    4: .standard(proto: "topics_pattern"),
    5: .standard(proto: "topics_hash"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._watcherID == nil {return false}
    if self._namespace == nil {return false}
    if self._topicsPattern == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._watcherID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._namespace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._topicsPattern) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._topicsHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._watcherID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._namespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._topicsPattern {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._topicsHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandWatchTopicList, rhs: Pulsar_Proto_CommandWatchTopicList) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._watcherID != rhs._watcherID {return false}
    if lhs._namespace != rhs._namespace {return false}
    if lhs._topicsPattern != rhs._topicsPattern {return false}
    if lhs._topicsHash != rhs._topicsHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandWatchTopicListSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicListSuccess"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "watcher_id"),
    3: .same(proto: "topic"),
    4: .standard(proto: "topics_hash"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._watcherID == nil {return false}
    if self._topicsHash == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._watcherID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.topic) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._topicsHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._watcherID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.topic.isEmpty {
      try visitor.visitRepeatedStringField(value: self.topic, fieldNumber: 3)
    }
    try { if let v = self._topicsHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandWatchTopicListSuccess, rhs: Pulsar_Proto_CommandWatchTopicListSuccess) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._watcherID != rhs._watcherID {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._topicsHash != rhs._topicsHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandWatchTopicUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "watcher_id"),
    2: .standard(proto: "new_topics"),
    3: .standard(proto: "deleted_topics"),
    4: .standard(proto: "topics_hash"),
  ]

  public var isInitialized: Bool {
    if self._watcherID == nil {return false}
    if self._topicsHash == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._watcherID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.newTopics) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.deletedTopics) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._topicsHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._watcherID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.newTopics.isEmpty {
      try visitor.visitRepeatedStringField(value: self.newTopics, fieldNumber: 2)
    }
    if !self.deletedTopics.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deletedTopics, fieldNumber: 3)
    }
    try { if let v = self._topicsHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandWatchTopicUpdate, rhs: Pulsar_Proto_CommandWatchTopicUpdate) -> Bool {
    if lhs._watcherID != rhs._watcherID {return false}
    if lhs.newTopics != rhs.newTopics {return false}
    if lhs.deletedTopics != rhs.deletedTopics {return false}
    if lhs._topicsHash != rhs._topicsHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandWatchTopicListClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandWatchTopicListClose"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "watcher_id"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._watcherID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._watcherID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._watcherID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandWatchTopicListClose, rhs: Pulsar_Proto_CommandWatchTopicListClose) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._watcherID != rhs._watcherID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetSchema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetSchema"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "topic"),
    3: .standard(proto: "schema_version"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._topic == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._schemaVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._schemaVersion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetSchema, rhs: Pulsar_Proto_CommandGetSchema) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._topic != rhs._topic {return false}
    if lhs._schemaVersion != rhs._schemaVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetSchemaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "error_code"),
    3: .standard(proto: "error_message"),
    4: .same(proto: "schema"),
    5: .standard(proto: "schema_version"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if let v = self._schema, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._errorCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._errorMessage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._schemaVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._errorCode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._errorMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._schemaVersion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetSchemaResponse, rhs: Pulsar_Proto_CommandGetSchemaResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._errorCode != rhs._errorCode {return false}
    if lhs._errorMessage != rhs._errorMessage {return false}
    if lhs._schema != rhs._schema {return false}
    if lhs._schemaVersion != rhs._schemaVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetOrCreateSchema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetOrCreateSchema"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "topic"),
    3: .same(proto: "schema"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._topic == nil {return false}
    if self._schema == nil {return false}
    if let v = self._schema, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetOrCreateSchema, rhs: Pulsar_Proto_CommandGetOrCreateSchema) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._topic != rhs._topic {return false}
    if lhs._schema != rhs._schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandGetOrCreateSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandGetOrCreateSchemaResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "error_code"),
    3: .standard(proto: "error_message"),
    4: .standard(proto: "schema_version"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._errorCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._errorMessage) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._schemaVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._errorCode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._errorMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._schemaVersion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandGetOrCreateSchemaResponse, rhs: Pulsar_Proto_CommandGetOrCreateSchemaResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._errorCode != rhs._errorCode {return false}
    if lhs._errorMessage != rhs._errorMessage {return false}
    if lhs._schemaVersion != rhs._schemaVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandTcClientConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandTcClientConnectRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "tc_id"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if self._tcID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._tcID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tcID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandTcClientConnectRequest, rhs: Pulsar_Proto_CommandTcClientConnectRequest) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._tcID != rhs._tcID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandTcClientConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandTcClientConnectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "error"),
    3: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandTcClientConnectResponse, rhs: Pulsar_Proto_CommandTcClientConnectResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandNewTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandNewTxn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txn_ttl_seconds"),
    3: .standard(proto: "tc_id"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnTtlSeconds) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._tcID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnTtlSeconds {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tcID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandNewTxn, rhs: Pulsar_Proto_CommandNewTxn) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnTtlSeconds != rhs._txnTtlSeconds {return false}
    if lhs._tcID != rhs._tcID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandNewTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandNewTxnResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandNewTxnResponse, rhs: Pulsar_Proto_CommandNewTxnResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAddPartitionToTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAddPartitionToTxn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "partitions"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.partitions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    if !self.partitions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.partitions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAddPartitionToTxn, rhs: Pulsar_Proto_CommandAddPartitionToTxn) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs.partitions != rhs.partitions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAddPartitionToTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAddPartitionToTxnResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAddPartitionToTxnResponse, rhs: Pulsar_Proto_CommandAddPartitionToTxnResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_Subscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "subscription"),
  ]

  public var isInitialized: Bool {
    if self._topic == nil {return false}
    if self._subscription == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._subscription) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subscription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_Subscription, rhs: Pulsar_Proto_Subscription) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._subscription != rhs._subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAddSubscriptionToTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAddSubscriptionToTxn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "subscription"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.subscription) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.subscription) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    if !self.subscription.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscription, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAddSubscriptionToTxn, rhs: Pulsar_Proto_CommandAddSubscriptionToTxn) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandAddSubscriptionToTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAddSubscriptionToTxnResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandAddSubscriptionToTxnResponse, rhs: Pulsar_Proto_CommandAddSubscriptionToTxnResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandEndTxn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandEndTxn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .standard(proto: "txn_action"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._txnAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._txnAction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandEndTxn, rhs: Pulsar_Proto_CommandEndTxn) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._txnAction != rhs._txnAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandEndTxnResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandEndTxnResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandEndTxnResponse, rhs: Pulsar_Proto_CommandEndTxnResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandEndTxnOnPartition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnPartition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "topic"),
    5: .standard(proto: "txn_action"),
    6: .standard(proto: "txnid_least_bits_of_low_watermark"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._txnAction) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBitsOfLowWatermark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._txnAction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._txnidLeastBitsOfLowWatermark {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandEndTxnOnPartition, rhs: Pulsar_Proto_CommandEndTxnOnPartition) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._topic != rhs._topic {return false}
    if lhs._txnAction != rhs._txnAction {return false}
    if lhs._txnidLeastBitsOfLowWatermark != rhs._txnidLeastBitsOfLowWatermark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandEndTxnOnPartitionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnPartitionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandEndTxnOnPartitionResponse, rhs: Pulsar_Proto_CommandEndTxnOnPartitionResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandEndTxnOnSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "subscription"),
    5: .standard(proto: "txn_action"),
    6: .standard(proto: "txnid_least_bits_of_low_watermark"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    if let v = self._subscription, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._subscription) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._txnAction) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBitsOfLowWatermark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._subscription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._txnAction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._txnidLeastBitsOfLowWatermark {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandEndTxnOnSubscription, rhs: Pulsar_Proto_CommandEndTxnOnSubscription) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._subscription != rhs._subscription {return false}
    if lhs._txnAction != rhs._txnAction {return false}
    if lhs._txnidLeastBitsOfLowWatermark != rhs._txnidLeastBitsOfLowWatermark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_CommandEndTxnOnSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandEndTxnOnSubscriptionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "txnid_least_bits"),
    3: .standard(proto: "txnid_most_bits"),
    4: .same(proto: "error"),
    5: .same(proto: "message"),
  ]

  public var isInitialized: Bool {
    if self._requestID == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._txnidLeastBits) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._txnidMostBits) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._txnidLeastBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._txnidMostBits {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse, rhs: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._txnidLeastBits != rhs._txnidLeastBits {return false}
    if lhs._txnidMostBits != rhs._txnidMostBits {return false}
    if lhs._error != rhs._error {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_BaseCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BaseCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "connect"),
    3: .same(proto: "connected"),
    4: .same(proto: "subscribe"),
    5: .same(proto: "producer"),
    6: .same(proto: "send"),
    7: .standard(proto: "send_receipt"),
    8: .standard(proto: "send_error"),
    9: .same(proto: "message"),
    10: .same(proto: "ack"),
    11: .same(proto: "flow"),
    12: .same(proto: "unsubscribe"),
    13: .same(proto: "success"),
    14: .same(proto: "error"),
    15: .standard(proto: "close_producer"),
    16: .standard(proto: "close_consumer"),
    17: .standard(proto: "producer_success"),
    18: .same(proto: "ping"),
    19: .same(proto: "pong"),
    20: .same(proto: "redeliverUnacknowledgedMessages"),
    21: .same(proto: "partitionMetadata"),
    22: .same(proto: "partitionMetadataResponse"),
    23: .same(proto: "lookupTopic"),
    24: .same(proto: "lookupTopicResponse"),
    25: .same(proto: "consumerStats"),
    26: .same(proto: "consumerStatsResponse"),
    27: .same(proto: "reachedEndOfTopic"),
    28: .same(proto: "seek"),
    29: .same(proto: "getLastMessageId"),
    30: .same(proto: "getLastMessageIdResponse"),
    31: .standard(proto: "active_consumer_change"),
    32: .same(proto: "getTopicsOfNamespace"),
    33: .same(proto: "getTopicsOfNamespaceResponse"),
    34: .same(proto: "getSchema"),
    35: .same(proto: "getSchemaResponse"),
    36: .same(proto: "authChallenge"),
    37: .same(proto: "authResponse"),
    38: .same(proto: "ackResponse"),
    39: .same(proto: "getOrCreateSchema"),
    40: .same(proto: "getOrCreateSchemaResponse"),
    50: .same(proto: "newTxn"),
    51: .same(proto: "newTxnResponse"),
    52: .same(proto: "addPartitionToTxn"),
    53: .same(proto: "addPartitionToTxnResponse"),
    54: .same(proto: "addSubscriptionToTxn"),
    55: .same(proto: "addSubscriptionToTxnResponse"),
    56: .same(proto: "endTxn"),
    57: .same(proto: "endTxnResponse"),
    58: .same(proto: "endTxnOnPartition"),
    59: .same(proto: "endTxnOnPartitionResponse"),
    60: .same(proto: "endTxnOnSubscription"),
    61: .same(proto: "endTxnOnSubscriptionResponse"),
    62: .same(proto: "tcClientConnectRequest"),
    63: .same(proto: "tcClientConnectResponse"),
    64: .same(proto: "watchTopicList"),
    65: .same(proto: "watchTopicListSuccess"),
    66: .same(proto: "watchTopicUpdate"),
    67: .same(proto: "watchTopicListClose"),
    68: .same(proto: "topicMigrated"),
  ]

  fileprivate class _StorageClass {
    var _type: Pulsar_Proto_BaseCommand.TypeEnum? = nil
    var _connect: Pulsar_Proto_CommandConnect? = nil
    var _connected: Pulsar_Proto_CommandConnected? = nil
    var _subscribe: Pulsar_Proto_CommandSubscribe? = nil
    var _producer: Pulsar_Proto_CommandProducer? = nil
    var _send: Pulsar_Proto_CommandSend? = nil
    var _sendReceipt: Pulsar_Proto_CommandSendReceipt? = nil
    var _sendError: Pulsar_Proto_CommandSendError? = nil
    var _message: Pulsar_Proto_CommandMessage? = nil
    var _ack: Pulsar_Proto_CommandAck? = nil
    var _flow: Pulsar_Proto_CommandFlow? = nil
    var _unsubscribe: Pulsar_Proto_CommandUnsubscribe? = nil
    var _success: Pulsar_Proto_CommandSuccess? = nil
    var _error: Pulsar_Proto_CommandError? = nil
    var _closeProducer: Pulsar_Proto_CommandCloseProducer? = nil
    var _closeConsumer: Pulsar_Proto_CommandCloseConsumer? = nil
    var _producerSuccess: Pulsar_Proto_CommandProducerSuccess? = nil
    var _ping: Pulsar_Proto_CommandPing? = nil
    var _pong: Pulsar_Proto_CommandPong? = nil
    var _redeliverUnacknowledgedMessages: Pulsar_Proto_CommandRedeliverUnacknowledgedMessages? = nil
    var _partitionMetadata: Pulsar_Proto_CommandPartitionedTopicMetadata? = nil
    var _partitionMetadataResponse: Pulsar_Proto_CommandPartitionedTopicMetadataResponse? = nil
    var _lookupTopic: Pulsar_Proto_CommandLookupTopic? = nil
    var _lookupTopicResponse: Pulsar_Proto_CommandLookupTopicResponse? = nil
    var _consumerStats: Pulsar_Proto_CommandConsumerStats? = nil
    var _consumerStatsResponse: Pulsar_Proto_CommandConsumerStatsResponse? = nil
    var _reachedEndOfTopic: Pulsar_Proto_CommandReachedEndOfTopic? = nil
    var _seek: Pulsar_Proto_CommandSeek? = nil
    var _getLastMessageID: Pulsar_Proto_CommandGetLastMessageId? = nil
    var _getLastMessageIDResponse: Pulsar_Proto_CommandGetLastMessageIdResponse? = nil
    var _activeConsumerChange: Pulsar_Proto_CommandActiveConsumerChange? = nil
    var _getTopicsOfNamespace: Pulsar_Proto_CommandGetTopicsOfNamespace? = nil
    var _getTopicsOfNamespaceResponse: Pulsar_Proto_CommandGetTopicsOfNamespaceResponse? = nil
    var _getSchema: Pulsar_Proto_CommandGetSchema? = nil
    var _getSchemaResponse: Pulsar_Proto_CommandGetSchemaResponse? = nil
    var _authChallenge: Pulsar_Proto_CommandAuthChallenge? = nil
    var _authResponse: Pulsar_Proto_CommandAuthResponse? = nil
    var _ackResponse: Pulsar_Proto_CommandAckResponse? = nil
    var _getOrCreateSchema: Pulsar_Proto_CommandGetOrCreateSchema? = nil
    var _getOrCreateSchemaResponse: Pulsar_Proto_CommandGetOrCreateSchemaResponse? = nil
    var _newTxn: Pulsar_Proto_CommandNewTxn? = nil
    var _newTxnResponse: Pulsar_Proto_CommandNewTxnResponse? = nil
    var _addPartitionToTxn: Pulsar_Proto_CommandAddPartitionToTxn? = nil
    var _addPartitionToTxnResponse: Pulsar_Proto_CommandAddPartitionToTxnResponse? = nil
    var _addSubscriptionToTxn: Pulsar_Proto_CommandAddSubscriptionToTxn? = nil
    var _addSubscriptionToTxnResponse: Pulsar_Proto_CommandAddSubscriptionToTxnResponse? = nil
    var _endTxn: Pulsar_Proto_CommandEndTxn? = nil
    var _endTxnResponse: Pulsar_Proto_CommandEndTxnResponse? = nil
    var _endTxnOnPartition: Pulsar_Proto_CommandEndTxnOnPartition? = nil
    var _endTxnOnPartitionResponse: Pulsar_Proto_CommandEndTxnOnPartitionResponse? = nil
    var _endTxnOnSubscription: Pulsar_Proto_CommandEndTxnOnSubscription? = nil
    var _endTxnOnSubscriptionResponse: Pulsar_Proto_CommandEndTxnOnSubscriptionResponse? = nil
    var _tcClientConnectRequest: Pulsar_Proto_CommandTcClientConnectRequest? = nil
    var _tcClientConnectResponse: Pulsar_Proto_CommandTcClientConnectResponse? = nil
    var _watchTopicList: Pulsar_Proto_CommandWatchTopicList? = nil
    var _watchTopicListSuccess: Pulsar_Proto_CommandWatchTopicListSuccess? = nil
    var _watchTopicUpdate: Pulsar_Proto_CommandWatchTopicUpdate? = nil
    var _watchTopicListClose: Pulsar_Proto_CommandWatchTopicListClose? = nil
    var _topicMigrated: Pulsar_Proto_CommandTopicMigrated? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _connect = source._connect
      _connected = source._connected
      _subscribe = source._subscribe
      _producer = source._producer
      _send = source._send
      _sendReceipt = source._sendReceipt
      _sendError = source._sendError
      _message = source._message
      _ack = source._ack
      _flow = source._flow
      _unsubscribe = source._unsubscribe
      _success = source._success
      _error = source._error
      _closeProducer = source._closeProducer
      _closeConsumer = source._closeConsumer
      _producerSuccess = source._producerSuccess
      _ping = source._ping
      _pong = source._pong
      _redeliverUnacknowledgedMessages = source._redeliverUnacknowledgedMessages
      _partitionMetadata = source._partitionMetadata
      _partitionMetadataResponse = source._partitionMetadataResponse
      _lookupTopic = source._lookupTopic
      _lookupTopicResponse = source._lookupTopicResponse
      _consumerStats = source._consumerStats
      _consumerStatsResponse = source._consumerStatsResponse
      _reachedEndOfTopic = source._reachedEndOfTopic
      _seek = source._seek
      _getLastMessageID = source._getLastMessageID
      _getLastMessageIDResponse = source._getLastMessageIDResponse
      _activeConsumerChange = source._activeConsumerChange
      _getTopicsOfNamespace = source._getTopicsOfNamespace
      _getTopicsOfNamespaceResponse = source._getTopicsOfNamespaceResponse
      _getSchema = source._getSchema
      _getSchemaResponse = source._getSchemaResponse
      _authChallenge = source._authChallenge
      _authResponse = source._authResponse
      _ackResponse = source._ackResponse
      _getOrCreateSchema = source._getOrCreateSchema
      _getOrCreateSchemaResponse = source._getOrCreateSchemaResponse
      _newTxn = source._newTxn
      _newTxnResponse = source._newTxnResponse
      _addPartitionToTxn = source._addPartitionToTxn
      _addPartitionToTxnResponse = source._addPartitionToTxnResponse
      _addSubscriptionToTxn = source._addSubscriptionToTxn
      _addSubscriptionToTxnResponse = source._addSubscriptionToTxnResponse
      _endTxn = source._endTxn
      _endTxnResponse = source._endTxnResponse
      _endTxnOnPartition = source._endTxnOnPartition
      _endTxnOnPartitionResponse = source._endTxnOnPartitionResponse
      _endTxnOnSubscription = source._endTxnOnSubscription
      _endTxnOnSubscriptionResponse = source._endTxnOnSubscriptionResponse
      _tcClientConnectRequest = source._tcClientConnectRequest
      _tcClientConnectResponse = source._tcClientConnectResponse
      _watchTopicList = source._watchTopicList
      _watchTopicListSuccess = source._watchTopicListSuccess
      _watchTopicUpdate = source._watchTopicUpdate
      _watchTopicListClose = source._watchTopicListClose
      _topicMigrated = source._topicMigrated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._connect, !v.isInitialized {return false}
      if let v = _storage._connected, !v.isInitialized {return false}
      if let v = _storage._subscribe, !v.isInitialized {return false}
      if let v = _storage._producer, !v.isInitialized {return false}
      if let v = _storage._send, !v.isInitialized {return false}
      if let v = _storage._sendReceipt, !v.isInitialized {return false}
      if let v = _storage._sendError, !v.isInitialized {return false}
      if let v = _storage._message, !v.isInitialized {return false}
      if let v = _storage._ack, !v.isInitialized {return false}
      if let v = _storage._flow, !v.isInitialized {return false}
      if let v = _storage._unsubscribe, !v.isInitialized {return false}
      if let v = _storage._success, !v.isInitialized {return false}
      if let v = _storage._error, !v.isInitialized {return false}
      if let v = _storage._closeProducer, !v.isInitialized {return false}
      if let v = _storage._closeConsumer, !v.isInitialized {return false}
      if let v = _storage._producerSuccess, !v.isInitialized {return false}
      if let v = _storage._redeliverUnacknowledgedMessages, !v.isInitialized {return false}
      if let v = _storage._partitionMetadata, !v.isInitialized {return false}
      if let v = _storage._partitionMetadataResponse, !v.isInitialized {return false}
      if let v = _storage._lookupTopic, !v.isInitialized {return false}
      if let v = _storage._lookupTopicResponse, !v.isInitialized {return false}
      if let v = _storage._consumerStats, !v.isInitialized {return false}
      if let v = _storage._consumerStatsResponse, !v.isInitialized {return false}
      if let v = _storage._reachedEndOfTopic, !v.isInitialized {return false}
      if let v = _storage._seek, !v.isInitialized {return false}
      if let v = _storage._getLastMessageID, !v.isInitialized {return false}
      if let v = _storage._getLastMessageIDResponse, !v.isInitialized {return false}
      if let v = _storage._activeConsumerChange, !v.isInitialized {return false}
      if let v = _storage._getTopicsOfNamespace, !v.isInitialized {return false}
      if let v = _storage._getTopicsOfNamespaceResponse, !v.isInitialized {return false}
      if let v = _storage._getSchema, !v.isInitialized {return false}
      if let v = _storage._getSchemaResponse, !v.isInitialized {return false}
      if let v = _storage._ackResponse, !v.isInitialized {return false}
      if let v = _storage._getOrCreateSchema, !v.isInitialized {return false}
      if let v = _storage._getOrCreateSchemaResponse, !v.isInitialized {return false}
      if let v = _storage._newTxn, !v.isInitialized {return false}
      if let v = _storage._newTxnResponse, !v.isInitialized {return false}
      if let v = _storage._addPartitionToTxn, !v.isInitialized {return false}
      if let v = _storage._addPartitionToTxnResponse, !v.isInitialized {return false}
      if let v = _storage._addSubscriptionToTxn, !v.isInitialized {return false}
      if let v = _storage._addSubscriptionToTxnResponse, !v.isInitialized {return false}
      if let v = _storage._endTxn, !v.isInitialized {return false}
      if let v = _storage._endTxnResponse, !v.isInitialized {return false}
      if let v = _storage._endTxnOnPartition, !v.isInitialized {return false}
      if let v = _storage._endTxnOnPartitionResponse, !v.isInitialized {return false}
      if let v = _storage._endTxnOnSubscription, !v.isInitialized {return false}
      if let v = _storage._endTxnOnSubscriptionResponse, !v.isInitialized {return false}
      if let v = _storage._tcClientConnectRequest, !v.isInitialized {return false}
      if let v = _storage._tcClientConnectResponse, !v.isInitialized {return false}
      if let v = _storage._watchTopicList, !v.isInitialized {return false}
      if let v = _storage._watchTopicListSuccess, !v.isInitialized {return false}
      if let v = _storage._watchTopicUpdate, !v.isInitialized {return false}
      if let v = _storage._watchTopicListClose, !v.isInitialized {return false}
      if let v = _storage._topicMigrated, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._connect) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connected) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._subscribe) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._producer) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._send) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._sendReceipt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._sendError) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._ack) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._flow) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._unsubscribe) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._success) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._closeProducer) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._closeConsumer) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._producerSuccess) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._ping) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._pong) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._redeliverUnacknowledgedMessages) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._partitionMetadata) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._partitionMetadataResponse) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._lookupTopic) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._lookupTopicResponse) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._consumerStats) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._consumerStatsResponse) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._reachedEndOfTopic) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._seek) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._getLastMessageID) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._getLastMessageIDResponse) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._activeConsumerChange) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._getTopicsOfNamespace) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._getTopicsOfNamespaceResponse) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._getSchema) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._getSchemaResponse) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._authChallenge) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._authResponse) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._ackResponse) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._getOrCreateSchema) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._getOrCreateSchemaResponse) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._newTxn) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._newTxnResponse) }()
        case 52: try { try decoder.decodeSingularMessageField(value: &_storage._addPartitionToTxn) }()
        case 53: try { try decoder.decodeSingularMessageField(value: &_storage._addPartitionToTxnResponse) }()
        case 54: try { try decoder.decodeSingularMessageField(value: &_storage._addSubscriptionToTxn) }()
        case 55: try { try decoder.decodeSingularMessageField(value: &_storage._addSubscriptionToTxnResponse) }()
        case 56: try { try decoder.decodeSingularMessageField(value: &_storage._endTxn) }()
        case 57: try { try decoder.decodeSingularMessageField(value: &_storage._endTxnResponse) }()
        case 58: try { try decoder.decodeSingularMessageField(value: &_storage._endTxnOnPartition) }()
        case 59: try { try decoder.decodeSingularMessageField(value: &_storage._endTxnOnPartitionResponse) }()
        case 60: try { try decoder.decodeSingularMessageField(value: &_storage._endTxnOnSubscription) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._endTxnOnSubscriptionResponse) }()
        case 62: try { try decoder.decodeSingularMessageField(value: &_storage._tcClientConnectRequest) }()
        case 63: try { try decoder.decodeSingularMessageField(value: &_storage._tcClientConnectResponse) }()
        case 64: try { try decoder.decodeSingularMessageField(value: &_storage._watchTopicList) }()
        case 65: try { try decoder.decodeSingularMessageField(value: &_storage._watchTopicListSuccess) }()
        case 66: try { try decoder.decodeSingularMessageField(value: &_storage._watchTopicUpdate) }()
        case 67: try { try decoder.decodeSingularMessageField(value: &_storage._watchTopicListClose) }()
        case 68: try { try decoder.decodeSingularMessageField(value: &_storage._topicMigrated) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._connect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connected {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._subscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._producer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._send {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._sendReceipt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sendError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._ack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._flow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._unsubscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._success {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._closeProducer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._closeConsumer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._producerSuccess {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._ping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._pong {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._redeliverUnacknowledgedMessages {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._partitionMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._partitionMetadataResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._lookupTopic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._lookupTopicResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._consumerStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._consumerStatsResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._reachedEndOfTopic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._seek {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._getLastMessageID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._getLastMessageIDResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._activeConsumerChange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._getTopicsOfNamespace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._getTopicsOfNamespaceResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._getSchema {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._getSchemaResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._authChallenge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._authResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._ackResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._getOrCreateSchema {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._getOrCreateSchemaResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._newTxn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._newTxnResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      } }()
      try { if let v = _storage._addPartitionToTxn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      } }()
      try { if let v = _storage._addPartitionToTxnResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      } }()
      try { if let v = _storage._addSubscriptionToTxn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      } }()
      try { if let v = _storage._addSubscriptionToTxnResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      } }()
      try { if let v = _storage._endTxn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      } }()
      try { if let v = _storage._endTxnResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      } }()
      try { if let v = _storage._endTxnOnPartition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      } }()
      try { if let v = _storage._endTxnOnPartitionResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      } }()
      try { if let v = _storage._endTxnOnSubscription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._endTxnOnSubscriptionResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      try { if let v = _storage._tcClientConnectRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      } }()
      try { if let v = _storage._tcClientConnectResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      } }()
      try { if let v = _storage._watchTopicList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      } }()
      try { if let v = _storage._watchTopicListSuccess {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
      } }()
      try { if let v = _storage._watchTopicUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      } }()
      try { if let v = _storage._watchTopicListClose {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      } }()
      try { if let v = _storage._topicMigrated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pulsar_Proto_BaseCommand, rhs: Pulsar_Proto_BaseCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._connect != rhs_storage._connect {return false}
        if _storage._connected != rhs_storage._connected {return false}
        if _storage._subscribe != rhs_storage._subscribe {return false}
        if _storage._producer != rhs_storage._producer {return false}
        if _storage._send != rhs_storage._send {return false}
        if _storage._sendReceipt != rhs_storage._sendReceipt {return false}
        if _storage._sendError != rhs_storage._sendError {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._ack != rhs_storage._ack {return false}
        if _storage._flow != rhs_storage._flow {return false}
        if _storage._unsubscribe != rhs_storage._unsubscribe {return false}
        if _storage._success != rhs_storage._success {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._closeProducer != rhs_storage._closeProducer {return false}
        if _storage._closeConsumer != rhs_storage._closeConsumer {return false}
        if _storage._producerSuccess != rhs_storage._producerSuccess {return false}
        if _storage._ping != rhs_storage._ping {return false}
        if _storage._pong != rhs_storage._pong {return false}
        if _storage._redeliverUnacknowledgedMessages != rhs_storage._redeliverUnacknowledgedMessages {return false}
        if _storage._partitionMetadata != rhs_storage._partitionMetadata {return false}
        if _storage._partitionMetadataResponse != rhs_storage._partitionMetadataResponse {return false}
        if _storage._lookupTopic != rhs_storage._lookupTopic {return false}
        if _storage._lookupTopicResponse != rhs_storage._lookupTopicResponse {return false}
        if _storage._consumerStats != rhs_storage._consumerStats {return false}
        if _storage._consumerStatsResponse != rhs_storage._consumerStatsResponse {return false}
        if _storage._reachedEndOfTopic != rhs_storage._reachedEndOfTopic {return false}
        if _storage._seek != rhs_storage._seek {return false}
        if _storage._getLastMessageID != rhs_storage._getLastMessageID {return false}
        if _storage._getLastMessageIDResponse != rhs_storage._getLastMessageIDResponse {return false}
        if _storage._activeConsumerChange != rhs_storage._activeConsumerChange {return false}
        if _storage._getTopicsOfNamespace != rhs_storage._getTopicsOfNamespace {return false}
        if _storage._getTopicsOfNamespaceResponse != rhs_storage._getTopicsOfNamespaceResponse {return false}
        if _storage._getSchema != rhs_storage._getSchema {return false}
        if _storage._getSchemaResponse != rhs_storage._getSchemaResponse {return false}
        if _storage._authChallenge != rhs_storage._authChallenge {return false}
        if _storage._authResponse != rhs_storage._authResponse {return false}
        if _storage._ackResponse != rhs_storage._ackResponse {return false}
        if _storage._getOrCreateSchema != rhs_storage._getOrCreateSchema {return false}
        if _storage._getOrCreateSchemaResponse != rhs_storage._getOrCreateSchemaResponse {return false}
        if _storage._newTxn != rhs_storage._newTxn {return false}
        if _storage._newTxnResponse != rhs_storage._newTxnResponse {return false}
        if _storage._addPartitionToTxn != rhs_storage._addPartitionToTxn {return false}
        if _storage._addPartitionToTxnResponse != rhs_storage._addPartitionToTxnResponse {return false}
        if _storage._addSubscriptionToTxn != rhs_storage._addSubscriptionToTxn {return false}
        if _storage._addSubscriptionToTxnResponse != rhs_storage._addSubscriptionToTxnResponse {return false}
        if _storage._endTxn != rhs_storage._endTxn {return false}
        if _storage._endTxnResponse != rhs_storage._endTxnResponse {return false}
        if _storage._endTxnOnPartition != rhs_storage._endTxnOnPartition {return false}
        if _storage._endTxnOnPartitionResponse != rhs_storage._endTxnOnPartitionResponse {return false}
        if _storage._endTxnOnSubscription != rhs_storage._endTxnOnSubscription {return false}
        if _storage._endTxnOnSubscriptionResponse != rhs_storage._endTxnOnSubscriptionResponse {return false}
        if _storage._tcClientConnectRequest != rhs_storage._tcClientConnectRequest {return false}
        if _storage._tcClientConnectResponse != rhs_storage._tcClientConnectResponse {return false}
        if _storage._watchTopicList != rhs_storage._watchTopicList {return false}
        if _storage._watchTopicListSuccess != rhs_storage._watchTopicListSuccess {return false}
        if _storage._watchTopicUpdate != rhs_storage._watchTopicUpdate {return false}
        if _storage._watchTopicListClose != rhs_storage._watchTopicListClose {return false}
        if _storage._topicMigrated != rhs_storage._topicMigrated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pulsar_Proto_BaseCommand.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "CONNECT"),
    3: .same(proto: "CONNECTED"),
    4: .same(proto: "SUBSCRIBE"),
    5: .same(proto: "PRODUCER"),
    6: .same(proto: "SEND"),
    7: .same(proto: "SEND_RECEIPT"),
    8: .same(proto: "SEND_ERROR"),
    9: .same(proto: "MESSAGE"),
    10: .same(proto: "ACK"),
    11: .same(proto: "FLOW"),
    12: .same(proto: "UNSUBSCRIBE"),
    13: .same(proto: "SUCCESS"),
    14: .same(proto: "ERROR"),
    15: .same(proto: "CLOSE_PRODUCER"),
    16: .same(proto: "CLOSE_CONSUMER"),
    17: .same(proto: "PRODUCER_SUCCESS"),
    18: .same(proto: "PING"),
    19: .same(proto: "PONG"),
    20: .same(proto: "REDELIVER_UNACKNOWLEDGED_MESSAGES"),
    21: .same(proto: "PARTITIONED_METADATA"),
    22: .same(proto: "PARTITIONED_METADATA_RESPONSE"),
    23: .same(proto: "LOOKUP"),
    24: .same(proto: "LOOKUP_RESPONSE"),
    25: .same(proto: "CONSUMER_STATS"),
    26: .same(proto: "CONSUMER_STATS_RESPONSE"),
    27: .same(proto: "REACHED_END_OF_TOPIC"),
    28: .same(proto: "SEEK"),
    29: .same(proto: "GET_LAST_MESSAGE_ID"),
    30: .same(proto: "GET_LAST_MESSAGE_ID_RESPONSE"),
    31: .same(proto: "ACTIVE_CONSUMER_CHANGE"),
    32: .same(proto: "GET_TOPICS_OF_NAMESPACE"),
    33: .same(proto: "GET_TOPICS_OF_NAMESPACE_RESPONSE"),
    34: .same(proto: "GET_SCHEMA"),
    35: .same(proto: "GET_SCHEMA_RESPONSE"),
    36: .same(proto: "AUTH_CHALLENGE"),
    37: .same(proto: "AUTH_RESPONSE"),
    38: .same(proto: "ACK_RESPONSE"),
    39: .same(proto: "GET_OR_CREATE_SCHEMA"),
    40: .same(proto: "GET_OR_CREATE_SCHEMA_RESPONSE"),
    50: .same(proto: "NEW_TXN"),
    51: .same(proto: "NEW_TXN_RESPONSE"),
    52: .same(proto: "ADD_PARTITION_TO_TXN"),
    53: .same(proto: "ADD_PARTITION_TO_TXN_RESPONSE"),
    54: .same(proto: "ADD_SUBSCRIPTION_TO_TXN"),
    55: .same(proto: "ADD_SUBSCRIPTION_TO_TXN_RESPONSE"),
    56: .same(proto: "END_TXN"),
    57: .same(proto: "END_TXN_RESPONSE"),
    58: .same(proto: "END_TXN_ON_PARTITION"),
    59: .same(proto: "END_TXN_ON_PARTITION_RESPONSE"),
    60: .same(proto: "END_TXN_ON_SUBSCRIPTION"),
    61: .same(proto: "END_TXN_ON_SUBSCRIPTION_RESPONSE"),
    62: .same(proto: "TC_CLIENT_CONNECT_REQUEST"),
    63: .same(proto: "TC_CLIENT_CONNECT_RESPONSE"),
    64: .same(proto: "WATCH_TOPIC_LIST"),
    65: .same(proto: "WATCH_TOPIC_LIST_SUCCESS"),
    66: .same(proto: "WATCH_TOPIC_UPDATE"),
    67: .same(proto: "WATCH_TOPIC_LIST_CLOSE"),
    68: .same(proto: "TOPIC_MIGRATED"),
  ]
}
